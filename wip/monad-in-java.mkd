---
title: JavaでMonadを説明してみる
author: Yuji Yamamoto
tags: JavaScript, Monad, Java
date: February 25, 2016
...
---

「[モナドについてSwiftで説明してみた](http://qiita.com/koher/items/12f72f2fc2db7fa709cf)」という記事などで指摘されているように、
プログラマー向けにMonadを説明した記事は
サンプルがHaskellで書かれていることが多いので辛いですよね。

と、いうわけで上記の記事を引用しつつ、
HaskellよりもSwiftよりももっともっと広まっているであろう、
JavaでMonadを定義して説明してみたいと思います。  
これを通して、

- Monadの何が嬉しいのか
- なぜHaskellやScalaなど、一部の言語以外ではMonadがあんまり活用されないのか

と言った点も説明したいと思います！
僕自身Javaを勉強中なんで一石二鳥ですね！

# TL;DR (ここ以降がよくわかんなくてもとりあえず知ってもらいたいこと）

hoge

# とりあえずJavaでの定義を。

```java
interface Monad<T1> {
    // Haskellで言うところの >>= (bind)に該当します。
    <T2> Monad<T2> then(Function<T1, Monad<T2>>);

}
interface MonadFactory<T> {
    // Haskellで言うところのreturnに相当します。
    // 本当は1個のinterfaceにまとめたいけど
    // Javaのinterfaceでは無理っぽいorz.
    Monad<T> doNothingReturning(T);
}
```

Java 8がある程度普及した現在、関数を受けとる関数を表現するのがらくちんになりましたね！  
上記の通りMonadをJavaで表現すると、次のような日本語に言い換えることができます。

- 型変数を1つ受けとるinterfaceである。
- **`then`というメソッドを実装しなければならない。**
- `Monad<T1>`というクラスのインスタンスがあったとき、`then`は次の値を受け取り、返す。
    - 「`T1`を受け取り、別の型引数`T2`の`Monad`, `Monad<T2>`を返す関数」を受け取って、
    - `Monad<T2>`の値を返す。
- `Monad`を実装したクラスを実装したとき、任意のクラス値に対して、そのインスタンスを返すためのファクトリークラス（`MonadFactory`インターフェースを実装したクラス）も実装しなければならない [^refval]。

[refval]: 参照型と値型の区別はこの際お見逃しください。やっぱりJavaで厳密にMonadを表現するのは難しい。

すでに結構複雑で大変ですね！ ~~（半分はJavaのせいです！）~~  
いろいろ書きましたがここで特に大事なところは「**`then`というメソッドを実装しなければならない**」の一点です！  
`MonadFactory`は補助的なものだと思っていただいて差し支えありません！

## Monad則って？

上記の通り`Monad`インターフェースは、`then`メソッドと`MonadFactory`の`doNothingReturning`メソッド,
合わせて2つのメソッドを実装しなければなりません。  
加えて、これらのメソッドは「Monad則」というある一定の規則を満たさなければならないよう決まっています。  
ここではこの「Monad則」についてもJavaに置き換えて紹介します。

### なんでそんなのがあるの？

そもそも、なぜこんな規則があるのでしょう？  
この法則を満たすことで、Monadは非常に便利に使えるようになるのですが、それについては後ほど説明します。  
その代わり、ここではJavaで言うところの似たような「規則」を紹介することで、
「Monad則」の「立ち位置」みたいなものを理解していただきたいと思います。

お馴染み`Comparable`モジュールを思い出してください。
例えば下記のように振る舞う`Comparable`があったら嫌ですよね？

```java
/**
 * 引数とレシーバーを逆にしても1（より大きい）が返る！
 * どっちが本当に大きいの？
 */
x.compareTo(y) // => 1
y.compareTo(x) // => 1

/**
 * 自分自身と比較しても-1（より小さい）が返る！
 * どうやったら等しくなるんだ！？
 */
z.compareTo(z) // => -1
```

継承の仕方などによっては、
`Comparable`を実装していたとしても、
上記のようなおかしな振る舞いの`Comparable`を産み出してしまうことはあるでしょう。
もちろん意図的にそうした実装を作ることも可能です。  
このように不自然な`Comparable`を作らないためには、
`Comparable`を**実装する側が意識**しなければなりません。
コンパイラーが守ってくれないのです。

Monad則もこれと同じようなものです。  
Monadはそもそも圏論という数学の一分野で定義されたものなので、
その定義に準拠したものであるためには、
単純に`Monad`というインターフェースを実装するだけでなく、
それに沿うよう気を付けて中身(`then`と`doNothingReturning`)を実装しなければなりません。  
そして、繰り返しますがこのMonad則を満たすからこそみなさんはMonadを便利に使えるのです！
（詳細は後述！）

### で、Monad則ってどんなのさ？

前置きが長くなってしまいましたが、いよいよ「Monad則」をJavaで紹介しましょう！  
下記の通りです。

```java
// 任意の型X, Y, Zの値をx, y, zとします。
X x;
Y y;
Z z;

// それに対するMonadFactoryをfx, fyとします(fzは不要)
MonadFactory<X> fx = new MonadFactory<>;
MonadFactory<Y> fy = new MonadFactory<>;

// それから、Xを受け取って別のMonadの値を返す関数をax, ay, azとしましょう。
Function<X, Monad<Y>> ax = (x) -> ... ;
Function<Y, Monad<Z>> ay = (y) -> ... ;
Function<Z, Monad<A>> az = (z) -> ... ;

/ TODO: .equalsで書き換えるか他の表現方法を試す。

// 下記の式が**常にtrueを返す**doNothingReturningとthenを
// 実装している時、Monad則が成立します。
/* (A ) */ fx.doNothingReturning(x).then(ax) == ax.apply(x)
/* (A') */ ax.apply(x).then(fy::doNothingReturning) == ax.apply(x)
/* (B ) */
     ax.apply(x).then((y) -> ay.apply(y).then(az))
  == ax.apply(x).then(       ay        ).then(az)
```

<!--
return a >>= k  =  k a
m >>= return    =  m
m >>= (\x -> k x >>= h)  =  (m >>= k) >>= h
-->

各変数の定義まで書いてしまったので長ったらしくなってしまいましたが、一つずつ解説しましょう。

#### (A), (A')について

最初の2つは、どちらかというと`doNothingReturning`が守るべき性質についての式です。

第一に(A)では、
`x`に対して「なにもしないで」Monadの値を作って(`doNothingReturning(x)`)、
それから(`then`)、更にMonadを返す関数`ax`を実行するということは、
単に`ax`を1回実行するのと同じことだ --- つまり、
`doNothingReturning`をどんな`ax`の**前**に実行しても、
`ax`を実行するのと同じ、なので`doNothingReturning`は
**なにもしない**のと同等だ --- ということです。

(A')についても同様です。  
`x`を受け取ってMonadを返す関数`ax`を実行(`ax.apply(x)`)して、
それから(`then`)、「なにもしないで」Monadの値を作る(`doNothingReturning`)ことは、
単に`ax`を1回実行するのと同じことだ --- つまり、
`doNothingReturning`をどんな`ax`の**後**に実行しても、
`ax`を実行するのと同じ、なので`doNothingReturning`は
**なにもしない**のと同等だ --- ということです。

いずれにおいても、`doNothingReturning`は
**Monadの値を作って返すだけで、実質なにもしない**、という点を覚えておいてください。  
「そんなの役に立つの？」と思われるかもしれません。  
とりあえずは「定義上そう決まっているのでそういうものだ」とご理解しておいてください。
余力があったら後でよい例を紹介しましょう。

#### (B)について

(B)はちょっと複雑ですね。  
集中するために該当の部分だけ持ってきましょう。

```java
   ax.apply(x).then((y) -> ay.apply(y).then(az))
== ax.apply(x).then(       ay        ).then(az)
```

意図的にスペースを挟んで調整したので、勘のいい方はお気づきかもしれません。  
要するにこう↓いうことです。

hoge

上記の通り、1つめの`then`に渡す「Monadの値を返す関数」における`then(az)`の部分が、
一つめの`then`、つまり`ax.apply(x).then`に渡したラムダ式から、
**括り出せるようになっていなければならない**、ということです。  
後にも触れますが、これによって、ネストを一段平たくできたりします。

これをもうちょっとくだけた日本語に言い換えると、
「`ax.apply(x)`してから『`ay.apply(y)`してから`az`する』」ことと、
「`ax.apply(x)`してから『`ay.apply(y)`してから』『`az`する』」ことが、
常に同じ意味でないといけない、と解釈できます。  
この解釈だと「そんなの当たり前じゃないの？」と感じられるかもしれません。  
それぐらい直感的な仕様を守ってくださいね、というのが「Monad則」の正体だ、と考えていただければしっくりくるでしょうか？  
`Comparable`な`x`が常に`x.compareTo(x) == 0`であってほしいのと同じことです。

# ここまでのまとめ

さて、ここまでのまとめです。

- MonadをJavaで表現すると、`then`というメソッドを持ったインターフェースと、それに対応する、`doNothingReturning`というメソッドを持ったファクトリークラスのインターフェースで表現することができる。
- それらのインターフェースを実装するクラスは、下記の「Monad則」を満たすように`then`と`doNothingReturning`を実装しなければならない。
    - (A), (A') `doNothingReturning`はMonadの値を作って返すだけで、それ以外のことはしてはならない。
        ```java
               fx.doNothingReturning(x).then(ax) == ax.apply(x)
        ax.apply(x).then(fy::doNothingReturning) == ax.apply(x)
        ```
    - (B) 「`ax.apply(x)`してから『`ay.apply(y)`してから`az`する』」ことと、「`ax.apply(x)`してから『`ay.apply(y)`してから』『`az`する』」ことが、常に同じ意味でないとならない。
        ```java
           ax.apply(x).then((y) -> ay.apply(y).then(az))
        == ax.apply(x).then(       ay        ).then(az)
        ```

一点重要な注意事項を捕捉します。`then`や`doNothingReturning`などの**名前は私が勝手につけたもの**です。  
Haskellや数学の世界でどう呼んでいるかは各自調べてください。 

# 具体的な実装その1 Maybe

それではMonadについてもうちょっと具体的なイメージを持っていただくために、
前節で定義した`Monad`インターフェース(と、対応する`MonadFactory`)インターフェースを実装したクラスの例を紹介しましょう。

```java
class Maybe<T1> implements Monad<T2> {
    private final T1 x;

    Maybe(T1 x){
        this.x = x;
    }

    <T2> Monad<T2> then(Function<T1, Monad<T2>> nextAction){
        if (x != null){
            return nextAction.apply(x);
        } else {
            return new Maybe(null);
        }
    }
}

class MaybeFactory<T> implements Monad<T> {
    Monad<T> doNothingReturning(T x){
        return new Maybe<T>(x);
    }
}
```

上記は`then`において、持っている値(`x`)が`null`かどうかあらかじめ確認し、
`null`でなければ引数として渡した関数(`nextAction`)を実行します。  
次の関数(`nextAction`)を実行する前に「`null`でないか確認する」のが上記の`Maybe`クラスの`then`の役割です。  
Monad則のところで触れたように、
「Monadの値を作って返すだけで、それ以外のことはしない」のが`doNothingReturning`のお約束なので、
Monadインターフェースを実装するクラスをより明確に特徴付けるのは、`then`メソッドの方です。  
そのため繰り返しになりますが、
次の関数(`nextAction`)を実行する前に「`null`でないか確認する」のが上記の`Maybe`クラスの役割だ、と言い換えることもできるでしょう。

ところで、最近のJavaを使いなれた方は、`Maybe`がJava 8の`Optional`とそっくりなものであることにお気づきでしょう。  
`Maybe.then`は`Optional.flatMap`に相当し、`MaybeFactory.doNothingReturning`は`Optional.ofNullable`に相当します。
事実、その前提で[open-jdk](http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/util/Optional.java)のソースと見比べてみると、
上記は`Optional.java`を大幅に簡略化したものと同等であることがわかります [^haskell-maybe]。

[^haskell-maybe]: ちなみに、Haskellの`Maybe`とはちょっと異なる振る舞いをします。
Haskellの`Maybe`は、`return`が`null`に相当する`Nothing`を返すことはないからです。
`null`と`Nothing`は実際には大きく異なるものなので単純に比較できませんが。詳しくはHaskell勉強してみて確かめましょう！

`Optional`と同じようなものなので特に目新しい部分はないかもしれませんが、上記の`Maybe`の使用例を示しましょう。

```java
Foo maybeFoo1 = someMap.get(key1);
MaybeFactory<Foo> f = new MaybeFactory<Foo>();
MaybeFactory<Bar> b = new MaybeFactory<Bar>();
Maybe<Bar> bar =
    f.doNothingReturning(maybeFoo1).then((foo1) -> {
        Foo maybeFoo2 = someMap.get(key2);
        return f.doNothingReturning(maybeFoo2).then((foo2) -> {
            Foo maybeFoo3 = someMap.get(key3);
            return f.doNothingReturning(maybeFoo3).then((foo3) -> {
                b.doNothingReturning(foo1.doSomething(foo2, foo3));
            });
        });
    });
```

上記のように、`null`を返すかもしれないメソッドがたくさん使うとき、
`Maybe`を使えば、`then`に`null`チェックをお任せすることができます。  
これでぬるぽともお別れだー！やったね！(^\_-)

...と、言いたいところですが、元ネタの`Optional.flatMap`使った場合と同様、ネストが深くって嫌ですねー。  
これでは普通にif文を書いた方がまだ読みやすそうです。`f.doNothingReturning`なんて書く分タイプ数も多いですし。

`f.doNothingReturning`や`MaybeFactory<Foo> f = new MaybeFactory<Foo>();`
の部分が長いのは単なる名付け方の名前だから（もっと短い名前を普及させればよいのであって）目をつぶるとして、
結局ネストが深くなってしまう問題はどうにかならないのでしょうか？

この問題を解決するヒントとして、前述の「Monad則」の(B)を思い出してみましょう。

```java
   ax.apply(x).then((y) -> ay.apply(y).then(az))
== ax.apply(x).then(       ay        ).then(az)
```

hoge

この規則は、上の図のように、2つめの`then`を1つめの`then`に渡したラムダ式から取り出すことで、
ネストを一段平たくすることができる、というものでした。  
おっ。ということは今回のケースにも適用できるかもしれませんよ！やってみましょう！

```java
Foo maybeFoo1;
Foo foo1, Foo foo2, Foo foo3;
MaybeFactory<Foo> f = new MaybeFactory<Foo>();
MaybeFactory<Bar> b = new MaybeFactory<Bar>();

maybeFoo1 = someMap.get(key1);
Maybe<Bar> bar =
    f.doNothingReturning(maybeFoo1).then((foo1Arg) -> {
        foo1 = foo1Arg;
        return f.doNothingReturning(someMap.get(key2));
    }).then((foo2Arg) -> {
        foo2 = foo2Arg;
        return f.doNothingReturning(someMap.get(key3));
    }).then((foo3Arg) -> {
        foo3 = foo3Arg;
        return b.doNothingReturning(foo1.doSomething(foo2, foo3));
    });
```

よし、これならネストが減ってちょっと見やすくなった...? と、思いきや、今度はコンパイルエラーです... (&gt;\_&lt;)  
Java 8のラムダ式は、ラムダ式の中でローカル変数を書き換えることができないのでしたorz  
残念ながらこの問題は、現在のJavaではどうしようもありません。  
しかもいずれにしてもいちいち`foo1 = foo1Arg`みたいな代入が必要だったりで、結局面倒くさいですよね。

実はHaskellであれば、上記のような書き換えを自動で行い、
自然な見た目にしてくれるシンタックスシュガー（構文糖）があります。  
それが次に示す「do記法」と呼ばれるものです。

# do記法

本記事はあくまでもJavaでMonadを説明する記事ですので、
ここではその「do記法」を仮にJavaに導入した場合を想像して、
先程の例がどのように書き換えられるか示しましょう。

```java
MaybeFactory<Foo> f = new MaybeFactory<Foo>();
MaybeFactory<Bar> b = new MaybeFactory<Bar>();

Maybe<Bar> bar = do {
    Foo foo1 <- f.doNothingReturning(someMap.get(key1));
    Foo foo2 <- f.doNothingReturning(someMap.get(key2));
    Foo foo3 <- f.doNothingReturning(someMap.get(key3));
    b.doNothingReturning(foo1.doSomething(foo2, foo3));
};
```

# 具体的な実装 その2 State

# 具体的な実装 その3 Promise

Java 8のCompletableFutureとおんなじ。

# fmapなどのユーティリティ

# 参考

[モナドについてSwiftで説明してみた - Qiita](http://qiita.com/koher/items/12f72f2fc2db7fa709cf)
[hoge](http://stackoverflow.com/questions/3164334/how-can-i-force-a-constructor-to-be-defined-in-all-subclass-of-my-abstract-class)
