---
title: JavaでMonadを説明してみる
author: Yuji Yamamoto
tags: JavaScript, Monad, Java
date: February 25, 2016
...
---

「[モナドについてSwiftで説明してみた](http://qiita.com/koher/items/12f72f2fc2db7fa709cf)」という記事などで指摘されているように、
プログラマー向けにMonadを説明した記事は
サンプルがHaskellで書かれていることが多いので辛いですよね。

と、いうわけで上記の記事を引用しつつ、
HaskellよりもSwiftよりももっともっと広まっているであろう、
JavaでMonadを定義して説明してみたいと思います。  
これを通して、

- Monadの何が嬉しいのか
- なぜHaskellやScalaなど、一部の言語以外ではMonadがあんまり活用されないのか

と言った点も説明したいと思います！
僕自身Javaを勉強中なんで一石二鳥ですね！

# TL;DR (ここ以降がよくわかんなくてもとりあえず知ってもらいたいこと）

hoge

# とりあえずJavaでの定義を。

```java
interface Monad<T1> {
    // Haskellで言うところの >>= (bind)に該当します。
    <T2> Monad<T2> then(Function<T1, Monad<T2>>);

}
interface MonadFactory<T> {
    // Haskellで言うところのreturnに相当します。
    // 本当は1個のinterfaceにまとめたいけど
    // Javaのinterfaceでは無理っぽいorz.
    Monad<T> doNothingReturning(T);
}
```

Java 8がある程度普及した現在、関数を受けとる関数を表現するのがらくちんになりましたね！  
上記の通りMonadをJavaで表現すると、次のような日本語に言い換えることができます。

- 型変数を1つ受けとるinterfaceである。
- **`then`というメソッドを実装しなければならない。**
- `Monad<T1>`というクラスのインスタンスがあったとき、`then`は次の値を受け取り、返す。
    - 「`T1`を受け取り、別の型引数`T2`の`Monad`, `Monad<T2>`を返す関数」を受け取って、
    - `Monad<T2>`の値を返す。
- `Monad`を実装したクラスを実装したとき、任意のクラス値に対して、そのインスタンスを返すためのファクトリークラス（`MonadFactory`インターフェースを実装したクラス）も実装しなければならない [^refval]。

[refval]: 参照型と値型の区別はこの際お見逃しください。やっぱりJavaで厳密にMonadを表現するのは難しい。

すでに結構複雑で大変ですね！ ~~（半分はJavaのせいです！）~~  
いろいろ書きましたがここで特に大事なところは「**`then`というメソッドを実装しなければならない**」の一点です！  
`MonadFactory`は補助的なものだと思っていただいて差し支えありません！

## Monad則って？

上記の通り`Monad`インターフェースは、`then`メソッドと`MonadFactory`の`doNothingReturning`メソッド,
合わせて2つのメソッドを実装しなければなりません。  
加えて、これらのメソッドは「Monad則」というある一定の規則を満たさなければならないよう決まっています。  
ここではこの「Monad則」についてもJavaに置き換えて紹介します。

### なんでそんなのがあるの？

そもそも、なぜこんな規則があるのでしょう？  
この法則を満たすことで、Monadは非常に便利に使えるようになるのですが、それについては後ほど説明します。  
その代わり、ここではJavaで言うところの似たような「規則」を紹介することで、
「Monad則」の「立ち位置」みたいなものを理解していただきたいと思います。

お馴染み`Comparable`モジュールを思い出してください。
例えば下記のように振る舞う`Comparable`があったら嫌ですよね？

```java
/**
 * 引数とレシーバーを逆にしても1（より大きい）が返る！
 * どっちが本当に大きいの？
 */
x.compareTo(y) // => 1
y.compareTo(x) // => 1

/**
 * 自分自身と比較しても-1（より小さい）が返る！
 * どうやったら等しくなるんだ！？
 */
z.compareTo(z) // => -1
```

継承の仕方などによっては、
`Comparable`を実装していたとしても、
上記のようなおかしな振る舞いの`Comparable`を産み出してしまうことはあるでしょう。
もちろん意図的にそうした実装を作ることも可能です。  
このように不自然な`Comparable`を作らないためには、
`Comparable`を**実装する側が意識**しなければなりません。
コンパイラーが守ってくれないのです。

Monad則もこれと同じようなものです。  
Monadはそもそも圏論という数学の一分野で定義されたものなので、
その定義に準拠したものであるためには、
単純に`Monad`というインターフェースを実装するだけでなく、
それに沿うよう気を付けて中身(`then`と`doNothingReturning`)を実装しなければなりません。  
そして、繰り返しますがこのMonad則を満たすからこそみなさんはMonadを便利に使えるのです！
（詳細は後述！）

### で、Monad則ってどんなのさ？

前置きが長くなってしまいましたが、いよいよ「Monad則」をJavaで紹介しましょう！  
下記の通りです。

```java
// 任意の型X, Y, Zの値をx, y, zとします。
X x;
Y y;
Z z;

// それに対するMonadFactoryをfx, fyとします(fzは不要)
MonadFactory<X> fx = new MonadFactory<>;
MonadFactory<Y> fy = new MonadFactory<>;

// それから、Xを受け取って別のMonadの値を返す関数をax, ay, azとしましょう。
Function<X, Monad<Y>> ax = (x) -> ... ;
Function<Y, Monad<Z>> ay = (y) -> ... ;
Function<Z, Monad<A>> az = (z) -> ... ;

/ TODO: .equalsで書き換えるか他の表現方法を試す。

// 下記の式が**常にtrueを返す**doNothingReturningとthenを
// 実装している時、Monad則が成立します。
/* (A ) */ fx.doNothingReturning(x).then(ax) == ax.apply(x)
/* (A') */ ax.apply(x).then(fy::doNothingReturning) == ax.apply(x)
/* (B ) */
     ax.apply(x).then((y) -> ay.apply(y).then(az))
  == ax.apply(x).then(       ay        ).then(az)
```

<!--
return a >>= k  =  k a
m >>= return    =  m
m >>= (\x -> k x >>= h)  =  (m >>= k) >>= h
-->

各変数の定義まで書いてしまったので長ったらしくなってしまいましたが、一つずつ解説しましょう。

### (A), (A')について

最初の2つは、どちらかというと`doNothingReturning`が守るべき性質についての式です。

第一に(A)では、
`x`に対して「なにもしないで」Monadの値を作って(`doNothingReturning(x)`)、
それから(`then`)、更にMonadを返す関数`ax`を実行するということは、
単に`ax`を1回実行するのと同じことだ --- つまり、
`doNothingReturning`をどんな`ax`の**前**に実行しても、
`ax`を実行するのと同じ、なので`doNothingReturning`は
**なにもしない**のと同等だ --- ということです。

(A')についても同様です。  
`x`を受け取ってMonadを返す関数`ax`を実行(`ax.apply(x)`)して、
それから(`then`)、「なにもしないで」Monadの値を作る(`doNothingReturning`)ことは、
単に`ax`を1回実行するのと同じことだ --- つまり、
`doNothingReturning`をどんな`ax`の**後**に実行しても、
`ax`を実行するのと同じ、なので`doNothingReturning`は
**なにもしない**のと同等だ --- ということです。

いずれにおいても、`doNothingReturning`は
**Monadの値を作って返すだけで、実質なにもしない**、という点を覚えておいてください。  
「そんなの役に立つの？」と思われるかもしれません。  
とりあえずは「定義上そう決まっているのでそういうものだ」とご理解しておいてください。
余力があったら後でよい例を紹介しましょう。

### (B)について

(B)はちょっと複雑ですね。  
集中するために該当の部分だけ持ってきましょう。

```java
   ax.apply(x).then((y) -> ay.apply(y).then(az))
== ax.apply(x).then(       ay        ).then(az)
```

意図的にスペースを挟んで調整したので、勘のいい方はお気づきかもしれません。  
要するにこう↓いうことです。

hoge

上記の通り、1つめの`then`に渡す「Monadの値を返す関数」における`then(az)`の部分が、
一つめの`then`、つまり`ax.apply(x).then`の引数から、
**括り出せるようになっていなければならない**、ということです。

これをもうちょっとくだけた日本語に言い換えると、
「`ax.apply(x)`してから『`ay.apply(y)`してから`az`する』」ことと、
「`ax.apply(x)`してから『`ay.apply(y)`してから』『`az`する』」ことが、
常に同じ意味でないといけない、と解釈できます。  
この解釈だと「そんなの当たり前じゃないの？」と感じられるかもしれません。  
それぐらい直感的な仕様を守ってくださいね、というのが「Monad則」の正体だ、と考えていただければしっくりくるでしょうか？  
`Comparable`な`x`が常に`x.compareTo(x) == 0`であってほしいのと同じことです。

## ここまでのまとめ

さて、ここまでのまとめです。

- MonadをJavaで表現すると、`then`というメソッドを持ったインターフェースと、それに対応する、`doNothingReturning`というメソッドを持ったファクトリークラスのインターフェースで表現することができる。
- それらのインターフェースを実装するクラスは、下記の「Monad則」を満たすように`then`と`doNothingReturning`を実装しなければならない。
    - (A), (A') `doNothingReturning`はMonadの値を作って返すだけで、それ以外のことはしてはならない。
        ```java
               fx.doNothingReturning(x).then(ax) == ax.apply(x)
        ax.apply(x).then(fy::doNothingReturning) == ax.apply(x)
        ```
    - (B) 「`ax.apply(x)`してから『`ay.apply(y)`してから`az`する』」ことと、「`ax.apply(x)`してから『`ay.apply(y)`してから』『`az`する』」ことが、常に同じ意味でないとならない。
        ```java
           ax.apply(x).then((y) -> ay.apply(y).then(az))
        == ax.apply(x).then(       ay        ).then(az)
        ```

一点重要な注意事項。`then`や`doNothingReturning`などの**名前は私が勝手につけたもの**です。  
Haskellや数学の世界でどう呼んでいるかは各自調べてください。 

# 具体的な実装を見てみましょう

それではMonadについてもうちょっと具体的なイメージを持っていただくために、
前節で定義した`Monad`インターフェース(と、対応する`MonadFactory`)インターフェースを実装したクラスの例を紹介しましょう。

```java
class Maybe<T1> implements Monad<T2> {
    private final T1 x;

    Maybe(T1 x){
        this.x = x;
    }

    <T2> Monad<T2> then(Function<T1, Monad<T2>> nextAction){
        if (x != null){
            return nextAction.apply(x);
        } else {
            return new Maybe(null);
        }
    }
}
class MaybeFactory<T> implements Monad<T> {
    Monad<T> doNothingReturning(T x){
        return new Maybe<T>(x);
    }
}
```

上記は`then`においてhoge
事実、[open-jdk](http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/util/Optional.java)のソースと見比べてみると、
上記は`Optional.java`を大幅に簡略化したものと同等であることがわかります。

# do記法

# 参考

[モナドについてSwiftで説明してみた - Qiita](http://qiita.com/koher/items/12f72f2fc2db7fa709cf)
[hoge](http://stackoverflow.com/questions/3164334/how-can-i-force-a-constructor-to-be-defined-in-all-subclass-of-my-abstract-class)
