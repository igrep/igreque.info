---
title: JavaでMonadを説明してみる
author: Yuji Yamamoto
tags: JavaScript, Monad, Java
date: February 25, 2016
...
---

「[モナドについてSwiftで説明してみた](http://qiita.com/koher/items/12f72f2fc2db7fa709cf)」という記事などで指摘されているように、
プログラマー向けにMonadを説明した記事は
サンプルがHaskellで書かれていることが多いので辛いですよね。

と、いうわけで上記の記事を参考にしつつ、
HaskellよりもSwiftよりももっともっと広まっているであろう、
JavaでMonadを定義して説明してみたいと思います。  
これを通して、

- Monadの何が嬉しいのか
- なぜHaskellやScalaなど、一部の言語以外ではMonadがあんまり活用されないのか

と言った点も説明したいと思います！
僕自身Javaを勉強中なんで一石二鳥ですね！

# TL;DR (ここ以降がよくわかんなくてもとりあえず知ってもらいたいこと）

hoge

# とりあえずJavaでの定義を。

```java
interface Monad<T1> {
    // Haskellで言うところの >>= (bind)に該当します。
    <T2> Monad<T2> then(Function<T1, Monad<T2>> action);

}
interface MonadFactory {
    // Haskellで言うところのreturnに相当します。
    // 本当は1個のinterfaceにまとめたいけど
    // Javaのinterfaceでは無理っぽいorz.
    <T> Monad<T> doNothingReturning(T value);
}
```

Java 8がある程度普及した現在、関数を受けとる関数を表現するのがらくちんになりましたね！  
上記の通りMonadをJavaで表現すると、次のような日本語に言い換えることができます。

- 型変数を1つ受けとるinterfaceである。
- **`then`というメソッドを実装しなければならない。**
- `Monad<T1>`というクラスのインスタンスがあったとき、`then`は次の値を受け取り、返す。
    - 「`T1`を受け取り、別の型引数`T2`の`Monad`, `Monad<T2>`を返す関数」を受け取って、
    - `Monad<T2>`の値を返す。
- `Monad`を実装したクラスを実装したとき、任意のクラスの値に対して、そのインスタンスを返すためのファクトリークラス（`MonadFactory`インターフェースを実装したクラス）も実装しなければならない [^refval]。

[refval]: 参照型と値型の区別はこの際お見逃しください。やっぱりJavaで厳密にMonadを表現するのは難しい。

すでに結構複雑で大変ですね！ ~~（半分はJavaのせいです！）~~  
いろいろ書きましたがここで特に大事なところは「**`then`というメソッドを実装しなければならない**」の一点です！  
`MonadFactory`は補助的なものだと思っていただいて差し支えありません！

## Monad則って？

上記の通り`Monad`インターフェースは、`then`メソッドと`MonadFactory`の`doNothingReturning`メソッド,
合わせて2つのメソッドを実装しなければなりません。  
加えて、これらのメソッドは「Monad則」というある一定の規則を満たさなければならないよう決まっています。  
ここではこの「Monad則」についてもJavaに置き換えて紹介します。

### なんでそんなのがあるの？

そもそも、なぜこんな規則があるのでしょう？  
この法則を満たすことで、Monadは非常に便利に使えるようになるのですが、それについては後ほど説明します。  
その代わり、ここではJavaで言うところの似たような「規則」を紹介することで、
「Monad則」の「立ち位置」みたいなものを理解していただきたいと思います。

お馴染み`Comparable`インターフェースを思い出してください。
例えば下記のように振る舞う`Comparable`があったら嫌ですよね？

```java
/**
 * 引数とレシーバーを逆にしても1（より大きい）が返る！
 * どっちが本当に大きいの？
 */
x.compareTo(y) // => 1
y.compareTo(x) // => 1

/**
 * 自分自身と比較しても-1（より小さい）が返る！
 * どうやったら等しくなるんだ！？
 */
z.compareTo(z) // => -1
```

継承の仕方などによっては、
`Comparable`を実装していたとしても、
上記のようなおかしな振る舞いの`Comparable`を産み出してしまうことはあるでしょう。
もちろん意図的にそうした実装を作ることも可能です。  
このように不自然な`Comparable`を作らないためには、
`Comparable`を**実装する側が意識**しなければなりません。
コンパイラーが守ってくれないのです。

Monad則もこれと同じようなものです。  
Monadはそもそも圏論という数学の一分野で定義されたものなので、
その定義に準拠したものであるためには、
単純に`Monad`というインターフェースを実装するだけでなく、
それに沿うよう気を付けて中身(`then`と`doNothingReturning`)を実装しなければなりません。  
そして、繰り返しますがこのMonad則を満たすからこそみなさんはMonadを便利に使えるのです！
（詳細は後述！）

### で、Monad則ってどんなのさ？

前置きが長くなってしまいましたが、いよいよ「Monad則」をJavaで紹介しましょう！  
下記の通りです。

```java
// 任意の型X, Y, Zの値をx, y, zとします。
X x;
Y y;
Z z;

// MonadFactoryをfとします
MonadFactory<X> f = new SomeMonadFactory<>;

// それから、Xを受け取って別のMonadの値を返す関数をax, ay, azとしましょう。
Function<X, Monad<Y>> ax = (x) -> ... ;
Function<Y, Monad<Z>> ay = (y) -> ... ;
Function<Z, Monad<A>> az = (z) -> ... ;

// 下記の3組の式が**常に同じ意味となる**doNothingReturningとthenを
// 実装している時、Monad則が成立します。
/* (A ) */ f.doNothingReturning(x).then(ax)
           /* ↑と↓の意味が同じになること。以下同様。 */
           ax.apply(x)

/* (A') */ ax.apply(x).then(f::doNothingReturning)
           /* ↑と↓の意味が同じになること */
           ax.apply(x)

/* (B ) */ ax.apply(x).then((y) -> ay.apply(y).then(az))
           /* ↑と↓の意味が同じになること */
           ax.apply(x).then(       ay        ).then(az)
```

<!--
return a >>= k  =  k a
m >>= return    =  m
m >>= (\x -> k x >>= h)  =  (m >>= k) >>= h
-->

各変数の定義まで書いてしまったので長ったらしくなってしまいましたが、一つずつ解説しましょう。

#### (A), (A')について

最初の2つは、どちらかというと`doNothingReturning`が守るべき性質についての式です。

第一に(A)では、
`x`に対して「なにもしないで」Monadの値を作って(`doNothingReturning(x)`)、
それから(`then`)、更にMonadを返す関数`ax`を実行するということは、
単に`ax`を1回実行するのと同じことだ --- つまり、
`doNothingReturning`をどんな`ax`の**前**に実行しても、
`ax`を実行するのと同じ、なので`doNothingReturning`は
**なにもしない**のと同等だ --- ということです。

(A')についても同様です。  
`x`を受け取ってMonadを返す関数`ax`を実行(`ax.apply(x)`)して、
それから(`then`)、「なにもしないで」Monadの値を作る(`doNothingReturning`)ことは、
単に`ax`を1回実行するのと同じことだ --- つまり、
`doNothingReturning`をどんな`ax`の**後**に実行しても、
`ax`を実行するのと同じ、なので`doNothingReturning`は
**なにもしない**のと同等だ --- ということです。

いずれにおいても、`doNothingReturning`は
**Monadの値を作って返すだけで、実質なにもしない**、という点を覚えておいてください。  
「そんなの役に立つの？」と思われるかもしれません。  
とりあえずは「定義上そう決まっているのでそういうものだ」とご理解しておいてください。
余力があったら後でよい例を紹介しましょう。

#### (B)について

(B)はちょっと複雑ですね。  
集中するために該当の部分だけ持ってきましょう。

```java
   ax.apply(x).then((y) -> ay.apply(y).then(az))
        /* ↑と↓の意味が同じになること */
   ax.apply(x).then(       ay        ).then(az)
```

意図的にスペースを挟んで調整したので、勘のいい方はお気づきかもしれません。  
要するにこう↓いうことです。

hoge

上記の通り、1つめの`then`に渡す「Monadの値を返す関数」における`then(az)`の部分が、
一つめの`then`、つまり`ax.apply(x).then`に渡したラムダ式から、
**括り出せるようになっていなければならない**、ということです。  
後にも触れますが、これによって、ネストを一段平たくできたりします。

これをもうちょっとくだけた日本語に言い換えると、
「`ax.apply(x)`してから『`ay.apply(y)`してから`az`する』」ことと、
「`ax.apply(x)`してから『`ay.apply(y)`してから』『`az`する』」ことが、
常に同じ意味でないといけない、と解釈できます。  
この解釈だと「そんなの当たり前じゃないの？」と感じられるかもしれません。  
それぐらい直感的な仕様を守ってくださいね、というのが「Monad則」の正体だ、と考えていただければしっくりくるでしょうか？  
`Comparable`な`x`が常に`x.compareTo(x) == 0`であってほしいのと同じことです。

# ここまでのまとめ

さて、ここまでのまとめです。

- MonadをJavaで表現すると、`then`というメソッドを持ったインターフェースと、それに対応する、`doNothingReturning`というメソッドを持ったファクトリークラスのインターフェースで表現することができる。
- それらのインターフェースを実装するクラスは、下記の「Monad則」を満たすように`then`と`doNothingReturning`を実装しなければならない。
    - (A), (A') `doNothingReturning`はMonadの値を作って返すだけで、それ以外のことはしてはならない。
        ```java
        /* ↓3行の意味が同じになること */
        f.doNothingReturning(x).then(ax)
        ax.apply(x).then(f::doNothingReturning)
        ax.apply(x)
        ```
    - (B) 「`ax.apply(x)`してから『`ay.apply(y)`してから`az`する』」ことと、「`ax.apply(x)`してから『`ay.apply(y)`してから』『`az`する』」ことが、常に同じ意味でないとならない。
        ```java
           ax.apply(x).then((y) -> ay.apply(y).then(az))
            /* ↑と↓の意味が同じになること */
           ax.apply(x).then(       ay        ).then(az)
        ```

一点重要な注意事項を捕捉します。`then`や`doNothingReturning`などの**名前は私が勝手につけたもの**です。  
Haskellや数学の世界でどう呼んでいるかは各自調べてください。 

# 具体的な実装その1 Maybe

それではMonadについてもうちょっと具体的なイメージを持っていただくために、
前節で定義した`Monad`インターフェース(と、対応する`MonadFactory`)インターフェースを実装したクラスの例を紹介しましょう。

```java
class Maybe<T1> implements Monad<T1> {
    private final T1 x;

    Maybe(T1 x){
        this.x = x;
    }

    <T2> Maybe<T2> then(Function<T1, Maybe<T2>> nextAction){
        if (x != null){
            return nextAction.apply(x);
        } else {
            return new Maybe(null);
        }
    }
}

class MaybeFactory implements MonadFactory {
    <T> Maybe<T> doNothingReturning(T x){
        return new Maybe<T>(x);
    }
}
```

上記は`then`において、持っている値(`x`)が`null`かどうかあらかじめ確認し、
`null`でなければ引数として渡した関数(`nextAction`)を実行します。  
次の関数(`nextAction`)を実行する前に「`null`でないか確認する」のが上記の`Maybe`クラスの`then`の役割です。  
Monad則のところで触れたように、
「Monadの値を作って返すだけで、それ以外のことはしない」のが`doNothingReturning`のお約束なので、
Monadインターフェースを実装するクラスをより明確に特徴付けるのは、`then`メソッドの方です。  
そのため繰り返しになりますが、
次の関数(`nextAction`)を実行する前に「`null`でないか確認する」のが上記の`Maybe`クラスの役割だ、と言い換えることもできるでしょう。

ところで、最近のJavaを使いなれた方は、`Maybe`がJava 8の`Optional`とそっくりなものであることにお気づきでしょう。  
`Maybe.then`は`Optional.flatMap`に相当し、`MaybeFactory.doNothingReturning`は`Optional.ofNullable`に相当すると考えると、確かに！  
事実、その前提で[open-jdkの`Optional.java`](http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/util/Optional.java)と見比べてみると、
上記は`Optional.java`を大幅に簡略化したものと同等であることがわかります [^haskell-maybe]。

[^haskell-maybe]: ちなみに、Haskellの`Maybe`とはちょっと異なる振る舞いをします。
Haskellの`Maybe`は、`return`が`null`に相当する`Nothing`を返すことはないからです。
`null`と`Nothing`は実際には大きく異なるものなので単純に比較できませんが。詳しくはHaskell勉強してみて確かめましょう！

`Optional`と同じようなものなので特に目新しい部分はないかもしれませんが、上記の`Maybe`の使用例を示しましょう。

```java
Foo maybeFoo1 = someMap.get(key1);
MaybeFactory<Foo> f = new MaybeFactory<Foo>();
MaybeFactory<Bar> b = new MaybeFactory<Bar>();
Maybe<Bar> bar =
    f.doNothingReturning(maybeFoo1).then((foo1) -> {
        Foo maybeFoo2 = someMap.get(key2);
        return f.doNothingReturning(maybeFoo2).then((foo2) -> {
            Foo maybeFoo3 = someMap.get(key3);
            return f.doNothingReturning(maybeFoo3).then((foo3) -> {
                b.doNothingReturning(foo1.doSomething(foo2, foo3));
            });
        });
    });
```

上記のように、`null`を返すかもしれないメソッドがたくさん使うとき、
`Maybe`を使えば、`then`に`null`チェックをお任せすることができます。  
これでぬるぽともお別れだー！やったね！(^\_-)

...と、言いたいところですが、元ネタの`Optional.flatMap`使った場合と同様、ネストが深くって嫌ですねー。  
これでは普通にif文を書いた方がまだ読みやすそうです。`f.doNothingReturning`なんて書く分タイプ数も多いですし。

`f.doNothingReturning`や`MaybeFactory<Foo> f = new MaybeFactory<Foo>();`
の部分が長いのは単なる名付け方の名前だから（もっと短い名前を普及させればよいのであって）目をつぶるとして、
結局ネストが深くなってしまう問題はどうにかならないのでしょうか？

この問題を解決するヒントとして、前述の「Monad則」の(B)を思い出してみましょう。

```java
/* (B ) */
    ax.apply(x).then((y) -> ay.apply(y).then(az))
        /* ↑と↓の意味が同じになること */
    ax.apply(x).then(       ay        ).then(az)
```

hoge

この規則は、上の図のように、2つめの`then`(hoge色の箇所)を1つめの`then`(hoge色の箇所)に渡したラムダ式から取り出すことで、
ネストを一段平たくすることができる、というものでした。  
おっ。ということは今回のケースにも適用できるかもしれませんよ！やってみましょう！

```java
Foo maybeFoo1;
Foo foo1, Foo foo2, Foo foo3;
MaybeFactory<Foo> f = new MaybeFactory<Foo>();
MaybeFactory<Bar> b = new MaybeFactory<Bar>();

maybeFoo1 = someMap.get(key1);
Maybe<Bar> bar =
    f.doNothingReturning(maybeFoo1).then((foo1Arg) -> {
        foo1 = foo1Arg;
        return f.doNothingReturning(someMap.get(key2));
    }).then((foo2Arg) -> {
        foo2 = foo2Arg;
        return f.doNothingReturning(someMap.get(key3));
    }).then((foo3Arg) -> {
        foo3 = foo3Arg;
        return b.doNothingReturning(foo1.doSomething(foo2, foo3));
    });
```

よし、これならネストが減ってちょっと見やすくなった...? と、思いきや、今度はコンパイルエラーです... (&gt;\_&lt;)  
Java 8のラムダ式は、ラムダ式の中でローカル変数を書き換えることができないのでしたorz  
残念ながらこの問題は、現在のJavaではどうしようもありません。  
しかもいずれにしてもいちいち`foo1 = foo1Arg`みたいな代入が必要だったりで、結局面倒くさいですよね。

実はHaskellであれば、上記のような書き換えを自動で行い、
自然な見た目にしてくれるシンタックスシュガー（構文糖）があります。  
それが次に示す「do記法」と呼ばれるものです。

# do記法

本記事はあくまでもJavaでMonadを説明する記事ですので、
ここではその「do記法」を**仮に**Javaに導入した場合を想像して、
先程の例がどのように書き換えられるか示しましょう。

```java
MaybeFactory f = new MaybeFactory<Foo>();

Maybe<Bar> bar = do {
    Foo foo1 <- f.doNothingReturning(someMap.get(key1));
    Foo foo2 <- f.doNothingReturning(someMap.get(key2));
    Foo foo3 <- f.doNothingReturning(someMap.get(key3));
    f.doNothingReturning(foo1.doSomething(foo2, foo3));
};
```

おお、`doNothingReturning`という長ったらしい名前さえどうにかなれば、
もはや普通のJavaと区別がつかないくらい自然じゃありませんか！  
どこがどう構文糖で簡略化されたのか申しますと、この場合、元のコードの`then`メソッドの呼び出しが、
細い矢印 `<-` の箇所に置き換わったと考えると分かりやすいでしょう。  
`then`メソッドが「引数として渡された関数」に渡す引数(上記の場合`foo1`, `foo2`, `foo3`)について`null`かどうか確認していたのを、
do記法では細い矢印`<-`で`foo1`, `foo2`, `foo3`に代入する前に`null`かどうか確認するようになったのです。  
このような自動的な書き換えがあるからこそ、HaskellではMonadが思いの外便利に使えるのです。  
どうです？Javaにもちょっと欲しくなりませんか？

## do記法とMonad則 (B)

ついでに、この「do記法」とMonad則(B)ののっぴきならない関係を示すことで、Monad則(B)を守ることの重要性についてもお話ししましょう。  
復習のためにもう一度↓に持ってきました。

```java
/* (B ) */
    ax.apply(x).then((y) -> ay.apply(y).then(az))
        /* ↑と↓の意味が同じになること */
    ax.apply(x).then(       ay        ).then(az)
```

上記の通りMonad則(B)は、
1つめの`then`に渡す「Monadの値を返す関数」における`then(az)`の部分が、
一つめの`then`、つまり`ax.apply(x).then`に渡したラムダ式から、
**処理の意味を変えずに、括り出せるようになっていなければならない**、ということでした。
これによってネストを一段平たくできるのでしたね。

この規則は、先程のdo記法を用いると、次のように表現することもできます。

```java
do {
    y <- ax.apply(x);
    do { // このdoブロック
        z <- ay.apply(y);
        az.apply(z);
    };
};
```

hoge: 色をコメントの色に合わせる
`// このdoブロック` と記されたdoブロックを引き剥がして、

```java
do {
    y <- ax.apply(x);
    z <- ay.apply(y);
    az.apply(z);
};
```

と必ず（処理の意味を変えずに）書き換えられなければならない、ということです。  
あるいは逆に`// このdoブロック`の場所をずらして、
hoge: 色をコメントの色に合わせる

```java
do {
    z <- do {
        y <- ax.apply(x);
        ay.apply(y);
    };
    az.apply(z);
};
```

のようにも書き換えられなければならない、とも言えます。

普通こんな無意味な書き換えはしないだろ、と思われるかもしれません。  
ところがリファクタリングしたくなったときなど、do記法で並べた各行を、他のメソッドとして切り出したくなったときはいかがでしょう？

先程の例で申しますと、

hoge
```java
do {
    y <- ax.apply(x);
    z <- ay.apply(y);
    az.apply(z);
};
```

上記のhoge色を塗った箇所だけ切り出して

```java
public SomeMonad<Z> extractedMethod(X x){
    do {
        y <- ax.apply(x);
        ay.apply(y);
    }
}

do {
    z <- extractedMethod(x);
    az.apply(z);
};
```

と書きたくなったり、  
上記のhoge色を塗った箇所だけを切り出して

```java
public SomeMonad<Bar> extractedMethod(Y y){
    do {
        z <- ax.apply(y);
        az.apply(z);
    }
}

do {
    y <- ax.apply(x);
    extractedMethod(y);
};
```

と書きたくなるかもしれません。

このように、do記法のどんなところから切り出しを行っても意味が変わらないようにするには、
Monad則(B)を満たして、入れ子を関係を気にしなくてもいいようにすることが、必要不可欠なのです。

# 具体的な実装 その2 State

さて、do記法のすごさが分かっていただけたところ（まだわからない場合、一番下までスクロールして、私にメールかIssueを送ってください！）で、
Monadの別の例を紹介しましょう。  
今度はJavaではあまり役に立たないとは思いますが、
**純粋な関数のみを使っているのに、あたかも命令型スタイルで書かれているかのように**見せる、魔法のようなMonadです。

ちょっとMonadじゃないクラスがいくつか出てきますが、Stateモナドが依存しているので、どうかご了承下さい。  
もちろん後で解説しますので...。

```java
// 状態を書き換えた結果を表すValue Object
class MutationResult<S, T> {
    public final S newState;
    public final T value;

    MutationResult(S newState, T value){
        this.newState = newState;
        this.value = value;
    }
}

// 状態の書き換えをシミュレートするための関数オブジェクト
@FunctionalInterface
interface StateMutator<T, S> {
    MutationResult<T, S> mutate(S oldState);
}

// Stateモナドの実装
class State<S, T1> implements Monad<T1> {
    private final StateMutator<T1, S> mutator;

    State(StateMutator<T1, S> mutator){
        this.mutator = mutator;
    }

    <T2> State<S, T2> then(Function<T1, State<S, T2>> nextAction){
        StateMutator<S, T2> composedMutator = (s) -> {
            MutationResult<S, T1> result = this.mutator.mutate(s);
            State<S, T2> other = nextAction.apply(result.value);
            return other.mutator.mutate(result.newState);
        }
        return new State(composedMutator);
    }

    // ないと困る、ユーティリティメソッド。引数で与えた状態に書き換える
    public static <S> State<S, Object> put(S newState){
        return new State(
            (ignoredState) -> new MutationResult(newState, null)
        );
    }

    // ないと困る、ユーティリティメソッド。現在の状態を取得する
    public static <S> State<S, S> get() {
        return new State(
            (currentState) -> new MutationResult(currentState, currentState)
        );
    }
}

class StateFactory<S> implements MonadFactory {
    <T> State<S, T> doNothingReturning(T value){
        return new State<S, T>(
            (nonMutatedState) -> new MutationResult(nonMutatedState, value)
        );
    }
}
```

うーん、肝心のStateクラス以外のものが多く、結構複雑ですね...`(^-^;`  
これだけでは何のこっちゃ、と感じられる方も多いと思うので、ちょっとずつ解説しましょう。

## そもそも、「純粋な関数」のみで命令型スタイルに見せる、とは？

ここで言う、「命令型スタイル」というのが「状態を書き換えることで結果を作る」プログラミングスタイルだとして、
関数型プログラミング、つまり純粋な関数のみを使用したスタイルでは、どうやって状態の書き換えを表現するのでしょう？  
純粋な関数は、戻り値を使用しない限り、関数の外部へ影響を与えることができません。  
ということで、素直に「古い状態を受け取って、新しい状態を返す」関数として表現してみましょう。  
Javaのインターフェースで言うと↓のような感じ。

```java
@FunctionalInterface
interface StateMutator0<S> {
    S mutate(S oldState);
}
```

しかしこれでは、「状態を書き換えたと同時に、別の値も返したい！」という時に不便ですよね。  
と、いうわけで出来たのが先ほど挙げました`MutationResult`と`StateMutator`です。  
↓にもう一度載せておきます。

```java
// 状態を書き換えた結果を表すValue Object
class MutationResult<S, T> {
    public final S newState;
    public final T value;

    MutationResult(S newState, T value){
        this.newState = newState;
        this.value = value;
    }
}

// 状態の書き換えをシミュレートするための関数オブジェクト
@FunctionalInterface
interface StateMutator<T, S> {
    MutationResult<T, S> mutate(S oldState);
}
```

「状態を書き換えたと同時に、別の値も返したい！」というニーズを満たすため、
「新しい状態」と「状態を書き換えたと同時に出てきた、別の値」とのペアを表すオブジェクト
`MutationResult`を作りました。`StateMutator`は古い状態を受け取って、それを返すだけです。

## `State`のコンストラクターがやっていること

```java
class State<S, T1> implements Monad<T1> {
    private final StateMutator<T1, S> mutator;

    State(StateMutator<T1, S> mutator){
        this.mutator = mutator;
    }
    // ...
}
```

コンストラクターでやっていることは単に引数をインスタンス変数にいれるだけのボイラープレートなコードです。  
ここで注目していただきたいのは、`State<S, T1>`は、
`StateMutator<T1, S>`, すなわち
「`S`という型の古い状態を受け取って、同じく`S`という型の**更新した状態と、一緒に出てきた`T1`という型の値を返す**関数」
をラップしただけのクラスであることです。  
`State` Monadはこれにちょっと色を着けるだけで、あたかも命令型スタイルで書いているかのように錯覚させることができるのです！

## `State.then`でやっていること

それでは本題、Monadインターフェースにとって最も重要なメソッド、`then`の`State`の詳細を解説しましょう。  
こちらは説明のために番号をコメントにふって載せますね。 ↓

``java
class State<S, T1> implements Monad<T1> {
    private final StateMutator<T1, S> mutator;
    // ...
    <T2> State<S, T2> then(Function<T1, State<S, T2>> nextAction){
        // (1) 新しいStateMutatorを作って、
        StateMutator<S, T2> composedMutator = (oldState) -> {
            // (2) 古い状態を書き換え、結果を受けとる
            MutationResult<S, T1> result = this.mutator.mutate(oldState);
            // (3) (2)で状態を書き換えた結果の値を、次のState Monadを作る関数へ渡す。
            State<S, T2> other = nextAction.apply(result.value);
            // (4) (2)で状態を書き換えた状態を処理する
            return other.mutator.mutate(result.newState);
        }
        // (1) また別の`State` Monadとしてくるみなおす。
        return new State(composedMutator);
    }
    // ...
}
```

まずは`(1)`を着けた**2ヶ所**に注目してください。
コメントに書いた通りですが、`State.then`メソッドでは`StateMutator`を作って、また`State`オブジェクトとしてくるみなおしています。  
後半の、`State`オブジェクトとしてくるみなおす部分は、型を合わせるためだけのものですので、
`State` Monadの`then`は(そしてその構文糖である`do`も)、
「**`StateMutator`をいい感じに組み合わせる**」ためにある、言う点を覚えておいてください。

`(2)`は最初の状態書き換えです。
結果を`MutationResult`として返すことで「書き換えた後の状態」と「一緒に返した値」を、`(3)`や`(4)`でそれぞれを利用できるようにします。

`(3)`では、`(2)`で手に入れた情報のうち、「一緒に返した値」を利用して、新しい`State` Monadを作ります。  
<!--
`result.value`を渡している`nextAction`の型を振り返ってみていただくと分かるのですが、
`nextAction`は「`Function<T1, State<S, T2>>`」と宣言されている通り、`T1`を受け取って、`State` Monadを返す関数となっているからです。
ちょっとややこしいですね。
-->

`(4)`

# 具体的な実装 その3 Promise

Java 8のCompletableFutureとおんなじ。

# fmapなどのユーティリティ

# 参考

[モナドについてSwiftで説明してみた - Qiita](http://qiita.com/koher/items/12f72f2fc2db7fa709cf)
[hoge](http://stackoverflow.com/questions/3164334/how-can-i-force-a-constructor-to-be-defined-in-all-subclass-of-my-abstract-class)
