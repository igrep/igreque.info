---
title: JavaでMonadを説明してみる
author: Yuji Yamamoto
tags: JavaScript, Monad, Java
date: February 25, 2016
...
---

「[モナドについてSwiftで説明してみた](http://qiita.com/koher/items/12f72f2fc2db7fa709cf)」という記事などで指摘されているように、
プログラマー向けにMonadを説明した記事は
サンプルがHaskellで書かれていることが多いので辛いですよね。

と、いうわけで上記の記事を引用しつつ、
HaskellよりもSwiftよりももっともっと広まっているであろう、
JavaでMonadを定義して説明してみたいと思います。  
これを通して、

- Monadの何が嬉しいのか
- なぜHaskellやScalaなど、一部の言語以外ではMonadがあんまり活用されないのか

と言った点も説明したいと思います！
僕自身Javaを勉強中なんで一石二鳥ですね！

# TL;DR (ここ以降がよくわかんなくてもとりあえず知ってもらいたいこと）

# とりあえずJavaでの定義を。

```java
interface Monad<T1> {
  // Haskellで言うところの >>= に該当します。
  <T2> Monad<T2> then(Function<T1, Monad<T2>>);

  // Haskellで言うところのreturnに相当します。
  // 本当は1個のinterfaceにまとめたいけど
  // Javaのinterfaceでは無理っぽいorz.
  interface MonadFactory<T> {
    Monad<T> doNothingReturning(T);
  }
}
```

Java 8がある程度普及した現在、関数を受けとる関数を表現するのがらくちんになりましたね！  
上記の通りMonadをJavaで表現すると、次のような日本語に言い換えることができます。

- 型変数を1つ受けとるinterfaceである。
- **`then`というメソッドを実装しなければならない。**
- `Monad<T1>`というクラスのインスタンスがあったとき、`then`は次の値を受け取り、返す。
    - 「`T1`を受け取り、別の型引数`T2`の`Monad`, `Monad<T2>`を返す関数」を受け取って、
    - `Monad<T2>`の値を返す。
- `Monad`を実装したクラスを実装したとき、任意のクラス値に対して、そのインスタンスを返すためのファクトリークラス（`MonadFactory`インターフェースを実装したクラス）も実装しなければならない [^refval]。

[refval]: 参照型と値型の区別はこの際お見のがしください。やっぱりJavaで厳密にMonadを表現するのは難しい。

すでに結構複雑で大変ですね！ ~~（半分はJavaのせいです！）~~  
いろいろ書きましたがここで特に大事なところは「**`then`というメソッドを実装しなければならない**」の一点です！  
`MonadFactory`は補助的なものだと思っていただいて差し支えありません！

## Monad則って？

上記の通り`Monad`インターフェースは、`then`メソッドと`MonadFactory`の`doNothingReturning`,
合わせて2つのメソッドを実装しなければなりません。  
加えて、これらのメソッドは「Monad則」というある一定の規則を満たさなければならないよう決まっています。  
ここではこの「Monad則」についてもJavaに置き換えて紹介します。

### なんでそんなのがあるの？

そもそも、なぜこんな規則があるのでしょう？  
この法則を満たすことで、Monadは非常に便利に使えるようになるのですが、それについては後ほど説明します。  
その代わり、ここではJavaで言うところの似たような「規則」を紹介することで、
「Monad則」の「立ち位置」みたいなものを理解していただきたいと思います。

お馴染み`Comparable`モジュールを思い出してください。
例えば下記のように振る舞う`Comparable`があったら嫌ですよね？

```java
/**
 * 引数とレシーバーを逆にしても1（より大きい）が返る！
 * どっちが本当に大きいの？
 */
x.compareTo(y) // => 1
y.compareTo(x) // => 1

/**
 * 自分自身と比較しても-1（より小さい）が返る！
 * どうやったら等しくなるんだ！？
 */
z.compareTo(z) // => -1
```

継承の仕方などによっては、
`Comparable`を実装していたとしても、
上記のようなおかしな振る舞いの`Comparable`を産み出してしまうことはあるでしょう。
もちろん意図的にそうした実装を作ることも可能です。  
このように不自然な`Comparable`を作らないためには、
`Comparable`を**実装する側が意識**しなければなりません。
コンパイラーが守ってくれないのです。

Monad則もこれと同じようなものです。  
Monadはそもそも圏論という数学の一分野で定義されたものなので、
その定義に準拠したものであるためには、
単純に`Monad`というインターフェースを実装するだけでなく、
それに沿うよう気を付けて中身(`then`と`doNothingReturning`)を実装しなければなりません。  
そして、繰り返しますがこのMonad則を満たすからこそみなさんはMonadを便利に使えるのです！
（詳細は後述！）

### で、Monad則ってどんなのさ？

前置きが長くなってしまいましたが、いよいよ「Monad則」をJavaで紹介しましょう！  
下記の通りです。

```java
// 任意の値をxとします。型も任意の型でも対応できなければなりません。
X x = ...;
// それに対するMonadFactoryをfとします。
MonadFactory<X> f = new MonadFactory<>;

f.doNothingReturning(x).then
```

return a >>= k  =  k a
m >>= return    =  m
m >>= (\x -> k x >>= h)  =  (m >>= k) >>= h

# 参考

[モナドについてSwiftで説明してみた - Qiita](http://qiita.com/koher/items/12f72f2fc2db7fa709cf)
