---
title: 関数型プログラミングから予測可能プログラミングへ: 純粋な関数・イミュータブルな構造
author: Yuji Yamamoto
tags: Haskell
date: August 29, 2015
...
---

*[このシリーズの目次はこちら](/posts/2015/2-predictable-programming-index.mkd)*

今回の記事で述べることは、恐らくいわゆる「関数型プログラミング」の特徴として、
十分に知られたものであろう。
本記事ではそれをHaskellの振る舞いに触れつつ説明することで、
そのメリットを簡単に復習したい。

本シリーズはあくまでもHaskellについてのシリーズであって、
関数型プログラミングについてのシリーズではない。  
本記事は次回 --- 恐らく僕がもっとも書きたい内容になるであろう ---
への布石とする。

# 純粋な関数

「純粋な関数」が何なのかは、[前の記事](/posts/2015/1-predictable-programming.html#definitionFunctionalProgramming)でも述べた。  
そうした「純粋な関数」が[「予測可能プログラミング」](/posts/2015/1-predictable-programming.html#definitionPredictableProgramming)
にもたらすメリットは実にシンプルだ。

一つは、関数がプログラムに及ぼす**影響範囲が、結果を渡した先(束縛する変数や別の関数の引数)のみに限定**されるので、
余計なことを考えなくてよい、ということである。

例えば、JavaScriptの`Array#sort`を考えてみよう。

```javascript
var sorted = array.sort();
```

上記のような行が仮にどこかのアプリケーションのコードに含まれていたとしよう。
これを書いた本人は、
`array.sort()`の及ぼす**影響範囲**を正しく理解していると言えるだろうか？  
実際のところ、これだけでは分からない。
なぜなら、JavaScriptの`Array#sort`メソッドは、
呼び出した`array`を破壊的に変更するためである。
これだけでは、`sort`の結果の代入先（この場合変数`sorted`）のみに影響を与えたいのか、
それとも、それに加えて`sort`を呼んだ`array`にも影響を与えたいのか、
意図するところが不明瞭になってしまうのである。

これに対して「純粋な関数」では、
その定義上、「出力(返り値)を返す」以外にプログラムの状態に影響を及ぼさないので、
書く人も読む人も関数の結果を渡す先のみのことを考えればよい。  
「純粋な関数」は、常に**関数のもたらす影響範囲が、非常に明瞭**なのだ。

この特徴は、
プログラミング言語が強くそれをサポート、あるいは強制することで、その真価を発揮する。  
すなわちイミュータブルなデータ構造や、書き換えできない変数の推奨である。  

例えば、再びJavaScriptを例にあげてみよう。  
ご存じの方も多いとは思うが、今となってはJavaScriptのような、
通常「関数型プログラミング言語」とは呼ばれない言語でも、
`map`, `filter`といった、
関数型プログラミングにおいて好んで使われる機能が提供されている。

```javascript
var mapped = array.map(function(n){
  if(n > 100){
    return processLargeValue(n);
  } else {
    return n;
  }
});
```

ところがJavaScriptのような、
関数が純粋な関数であってもなくてもよいような言語においては、
そうした機能の魅力は削がれがちである。
理由は単純で、上記の処理が本当に`array.map`の
結果を渡す先(この場合変数 `mapped`)以外に影響を与えないかどうかは、
`map`に渡した関数の中身、
この場合さらにその中で呼んでいる`processLargeValue`が純粋な関数かどうか、
すべてを読んで確認しないと分からないためである。  
そうした理由のためか、関数型プログラミングに慣れない人が書いたコードでは、
こうした奇妙な使い方をしがちである。

```javascript
var sum = 0;
var mapped = array.map(function(n){
  sum += n;
  return n * 2;
});
```

上記では、本来ならば`mapped`に値を代入するためだけにあるべき`map`が、
`sum`にも影響を与えてしまっている。
私は同僚が書いたコードのレビューで、しばしばこうしたミスを見かけた。  
言語の仕様であれなんであれ、何らかの形で再代入や破壊的変更の禁止を推奨しなければ、
純粋な関数の「関数の戻り値のみに影響を与えるから、影響範囲を予測しやすい」
という価値を容易に損なってしまうのだ。

そうした意味において、Haskellをはじめとする、
いわゆる「関数型プログラミング言語」と呼ばれる言語は、
そうでない言語では実現しにくい、大きなアドバンテージを持つのである[^mapM]。

[^mapM]: ちなみに、実はHaskellなどでも、
`mapM`や`filterM`といった関数を使えば上記と似たような処理は実現できる。
詳細は次回述べる予定。

## 力の弱い関数

純粋な関数が「予測可能プログラミング」にもたらすもう一つのメリットは、
関数が外部からの影響によって、その結果（戻り値）を変える要因が、
受け取った引数からのみに限定される、という点である。  
前節で述べたのが関数自身が外部に**与える**影響の範囲についてのメリットならば、
ここで述べるのは「関数自身が外部から**受ける**影響の範囲」である。  
当然ながらこの特徴により、
純粋な関数は、引数が少なければ少ないほど外部から影響を受ける要因が少なく、
その振る舞いを予測しやすいものとなる。

それを生かすことで、より「関数型プログラミング」らしい
（そして「予測可能プログラミング」らしい）スタイルでプログラムが書けるということを、
ここでは紹介する。
典型的な例は関数型プログラミングが好きな方にはお馴染みの、
`reduce`に対する`map`や`filter`であろう。  
再び例をJavaScriptで書こう。
下記は姓と名が空白で区切られて入った配列`names`のうち、
ちゃんと姓と名が空白文字で分かれて入っているもののみを、
姓と名のペア（要素数2の配列）に変換し、
姓名それぞれを大文字に変換する処理である。

1. mapやfilterを使った場合

```javascript
names.map(function(name){
  // 各文字列を空白文字で分割した結果の配列に変換して、
  //   e.g. ["a b", "c d", ...] => [["a", "b"], ["c", "d"], ...]
  // 次のfilterメソッドに渡す。
  return name.split(/\s+/);
}).filter(function(nameParts){
  return (
    // 空白文字でsplitするので、
    // 先頭末尾に空白文字含め余計な文字列がなければ、分割後は長さ2になる。
       nameParts.length === 2
    // なおかつ、姓名共に空でないもののみの配列を返す。
    && nameParts[0] && nameParts[1]
  );
}).map(function(nameParts){
  // 姓と名、両方を大文字にした結果を、
  var firstName = nameParts[0].toUpperCase();
  var lastName nameParts[1].toUpperCase();

  // 最終的な結果の配列として返す。
  return [firstName, lastName];
});
```

2. reduceを使った場合

```javascript
names.reduce(
  function(firstAndLastNames, nextName){
    // 文字列を空白文字で分割する。
    var nameParts = nextName.split(/\s+/);

    // 空白文字でsplitするので、
    // nextNameの先頭末尾に空白文字を含め余計な文字列がなければ、
    // 分割後は長さ2になる。
    if (nameParts.length !== 2){
      // 条件を満たさないので、結果の配列には追加しない。
      return firstAndLastNames;
    }

    // なおかつ、姓名共に空であってはいけない
    if (nameParts[0] && nameParts[1]){
      // 条件を満たさないので、結果の配列には追加しない。
      return firstAndLastNames;
    }

    // 姓と名、両方を大文字にした結果を、
    var firstName = nameParts[0].toUpperCase();
    var lastName nameParts[1].toUpperCase();

    // 最終的な結果の配列に追加する
    return firstAndLastNames.concat([[firstName, lastName]]);
  },
  [] // firstAndLastNamesの初期値。第一引数の関数が最初に実行される時に渡される。
)
```


# イミュータブルな変数・構造

続いて、同じく関数型プログラミングにとって必要不可欠な概念である、
イミュータブルな変数や構造がもたらすメリットについて説明する。

## 単純で極端な例

先ほどのJavaScriptの`Array#sort`の例を思い出していただきたい。  

```javascript
var sorted = array.sort();
```

これを書いた本人が、`array.sort()`の及ぼす**影響範囲**を正しく理解しているかどうかは、
このコードだけを見ても分からない、と先ほどは述べた。  
ところが、その人が[Prototype.js](http://prototypejs.org)の使用を前提としている、
と、仮定した場合、答えは異なる。  
Prototype.jsを利用した場合、標準の`Array#sort`は、
呼び出した`array`を破壊的に変更**しない**よう、書き換えられてしまうのである。  
これは実際の使い勝手と、Prototype.jsが参考にした、
Rubyの`Array#sort`の仕様を考慮して、よかれと思ってやったことであろう。
しかし実際にこれが原因で分かりづらいバグにはまった人もいらっしゃるのではないだろうか？
とりわけ既存のアプリケーションをPrototype.jsでリファクタリングする場合や、
逆にPrototype.jsで書かれたアプリケーションを移植する場合に、
この問題に出くわす可能性は高い。

JavaScriptの`Array#sort`や`undefined`など

## 並列処理との相性

# これだけではつまらないので次の予告を少し
