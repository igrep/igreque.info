---
title: 関数型プログラミングから予測可能プログラミングへ: 純粋な関数
author: Yuji Yamamoto
tags: Haskell
date: August 29, 2015
...
---

*[このシリーズの目次はこちら](/posts/2015/2-predictable-programming-index.mkd)*

今回の記事で述べることは、恐らくいわゆる「関数型プログラミング」の特徴として、
十分に知られたものであろう。
本記事ではそれをHaskellの振る舞いに触れつつ説明することで、
そのメリットを簡単に復習したい。

本シリーズはあくまでもHaskellについてのシリーズであって、
関数型プログラミングについてのシリーズではない。  
本記事は次回 --- 恐らく私がもっとも書きたい内容になるであろう ---
への布石とする。

# 純粋な関数

「純粋な関数」が何なのかは、[前の記事](/posts/2015/1-predictable-programming.html#definitionFunctionalProgramming)でも述べた。  
そうした「純粋な関数」が[「予測可能プログラミング」](/posts/2015/1-predictable-programming.html#definitionPredictableProgramming)
にもたらすメリットは実にシンプルだ。

一つは、関数がプログラムに及ぼす**影響範囲が、結果を渡した先(束縛する変数や別の関数の引数)のみに限定**されるので、
余計なことを考えなくてよい、ということである。

例えば、JavaScriptの`Array#sort`を考えてみよう。

```javascript
var sorted = array.sort();
```

上記のような行が仮にどこかのアプリケーションのコードに含まれていたとしよう。
これを書いた本人は、
`array.sort()`の及ぼす**影響範囲**を正しく理解していると言えるだろうか？  
実際のところ、これだけでは分からない。
なぜなら、JavaScriptの`Array#sort`メソッドは、
呼び出した`array`を破壊的に変更するためである。
これだけでは、`sort`の結果の代入先（この場合変数`sorted`）のみに影響を与えたいのか、
それとも、それに加えて`sort`を呼んだ`array`にも影響を与えたいのか、
意図するところが不明瞭になってしまうのである。

これに対して「純粋な関数」では、
その定義上、「出力(返り値)を返す」以外にプログラムの状態に影響を及ぼさないので、
書く人も読む人も関数の結果を渡す先のみのことを考えればよい。  
「純粋な関数」は、常に**関数のもたらす影響範囲が、非常に明瞭**なのだ。

この特徴は、
プログラミング言語が強くそれをサポート、あるいは強制することで、その真価を発揮する。  
すなわちイミュータブルなデータ構造や、書き換えできない変数の推奨である。  

例えば、再びJavaScriptを例にあげてみよう。  
ご存じの方も多いとは思うが、今となってはJavaScriptのような、
通常「関数型プログラミング言語」とは呼ばれない言語でも、
`map`, `filter`といった、
関数型プログラミングにおいて好んで使われる機能が提供されている。

```javascript
var mapped = array.map(function(n){
  if(n > 100){
    return processLargeValue(n);
  } else {
    return n;
  }
});
```

ところがJavaScriptのような、
関数が純粋な関数であってもなくてもよいような言語においては、
そうした機能の魅力は削がれがちである。
理由は単純で、上記の処理が本当に`array.map`の
結果を渡す先(この場合変数 `mapped`)以外に影響を与えないかどうかは、
`map`に渡した関数の中身、
この場合さらにその中で呼んでいる`processLargeValue`が純粋な関数かどうか、
すべてを読んで確認しないと分からないためである。  
そうした事情のためか、関数型プログラミングに慣れない人が書いたコードでは、
こうした奇妙な使い方を（意図するしないに関わらず）しがちである。

```javascript
var sum = 0;
var mapped = array.map(function(n){
  sum += n;
  return n * 2;
});
```

上記では、本来ならば`mapped`に値を代入するためだけにあるべき`map`が、
`sum`にも影響を与えてしまっている。
私は同僚が書いたコードのレビューで、しばしばこうしたミスを見かけた。  
言語の仕様であれなんであれ、何らかの形で再代入や破壊的変更の禁止を推奨しなければ、
純粋な関数の「関数の戻り値のみに影響を与えるから、影響範囲を予測しやすい」
という価値を容易に損なってしまうのだ。

そうした意味において、Haskellをはじめとする、
いわゆる「関数型プログラミング言語」と呼ばれる言語は、
そうでない言語では実現しにくい、大きなアドバンテージを持つのである[^mapM]。

[^mapM]: ちなみに、実はHaskellなどでも、
`mapM`や`filterM`といった関数を使えば上記と似たような処理は実現できる。
詳細は次回述べる予定。

## 力の弱い関数

純粋な関数が「予測可能プログラミング」にもたらすもう一つのメリットは、
関数がその結果（戻り値）を変える外的な要因が、
受け取った引数からのみに限定される、という点である。  
前節で述べたのが関数自身が外部に**与える**影響の範囲についてのメリットならば、
ここで述べるのは「関数自身が外部から**受ける**影響の範囲」である。  
当然ながらこの特徴により、
純粋な関数は、引数が少なければ少ないほど外部から影響を受ける要因が少なく、
その振る舞いを予測しやすいものとなる [^closure]。
それを生かすことで、より「関数型プログラミング」らしい
（そして「予測可能プログラミング」らしい）スタイルでプログラムが書けるということを、
ここでは紹介する。

[^closure]: 厳密に言えば、
関数の外で束縛された変数（`import`したものも含む）の影響も受ける。
しかしながらそれは当然純粋な関数に限ったことではなく、
相対的に純粋な関数の方が「関数自身が外部から**受ける**影響の範囲」が
狭いことには変わりないため、ここでは問題としない。

典型的な例は関数型プログラミングが好きな方にはお馴染みの、
`reduce`に対する`map`や`filter`であろう。  
再び例をJavaScriptで書こう。
下記は姓と名が空白で区切られて入った配列`names`のうち、
ちゃんと姓と名が空白文字で分かれて入っているもののみを、
姓と名のペア（要素数2の配列）に変換し、
姓名それぞれを大文字に変換する処理である。

1. mapやfilterを使った場合

```javascript
names.map(function(name){
  // 各文字列を空白文字で分割した結果の配列に変換して、
  //   e.g. ["a b", "c d", ...] => [["a", "b"], ["c", "d"], ...]
  // 次のfilterメソッドに渡す。
  return name.split(/\s+/);
}).filter(function(nameParts){
  return (
    // 空白文字でsplitするので、
    // 先頭末尾に空白文字含め余計な文字列がなければ、分割後は長さ2になる。
       nameParts.length === 2
    // なおかつ、姓名共に空でないもののみの配列を返す。
    && nameParts[0] && nameParts[1]
  );
}).map(function(nameParts){
  // 姓と名、両方を大文字にした結果を、
  var firstName = nameParts[0].toUpperCase();
  var lastName nameParts[1].toUpperCase();

  // 最終的な結果の配列として返す。
  return [firstName, lastName];
});
```

2. reduceを使った場合

```javascript
names.reduce(
  function(firstAndLastNames, name){
    // 文字列を空白文字で分割する。
    var nameParts = name.split(/\s+/);

    // 空白文字でsplitするので、
    // nextNameの先頭末尾に空白文字を含め余計な文字列がなければ、
    // 分割後は長さ2になる。
    if (nameParts.length !== 2){
      // 条件を満たさないので、結果の配列には追加しない。
      return firstAndLastNames;
    }

    // なおかつ、姓名共に空であってはいけない
    if (nameParts[0] && nameParts[1]){
      // 条件を満たさないので、結果の配列には追加しない。
      return firstAndLastNames;
    }

    // 姓と名、両方を大文字にした結果を、
    var firstName = nameParts[0].toUpperCase();
    var lastName nameParts[1].toUpperCase();

    // 最終的な結果の配列に追加する
    return firstAndLastNames.concat([[firstName, lastName]]);
  },
  [] // firstAndLastNamesの初期値。第一引数の関数が最初に実行される時に渡される。
)
```

「mapやfilterを使った場合」では、
「空白で区切る」、「大文字にする」といった、配列の各要素を「変換する」処理(`map`)と、
「姓名のみで構成されている」、「姓名それぞれの前後に空白文字が含まれない」といった、
特定の条件に該当する要素のみを「選ぶ」処理(`filter`)とで、使用する関数を分けている。  
`map`と`filter`, それぞれに渡す関数が受け取る引数はただ一つでよく、
これらの関数を使って「変換する」処理や「選ぶ」処理を書く際は、
それぞれに渡す関数が受け取るただ一つの引数
(この場合`name`や`nameParts`)についてのみ考えればよい。  
「純粋な関数」のみを使用していると仮定する限り、
一つの関数が受け取る引数は少なければ少ないほど、考慮すべき変数が減り、
より振る舞いを予測しやすくできるのだ。  
結果、関数を読む人も書く人も、一つ一つの関数の役割に集中することができる。  
これは、「一つのことをうまくやる」というUNIX哲学にも通じると言えよう。
「選ぶ」関数はその条件（何を選ぶか）だけを考え、
「変換する」関数はその変換した結果（何に変えるか）だけを考えればよいのである。  
このことは関数の振る舞いをより「予測可能にする」、
つまり「予測可能プログラミング」をする上で優れている。
純粋な関数は引数の数が少なければ少ないほど「予測可能」なのである。

それに対して「reduceを使った場合」では、
引数として渡した関数が、対象となる配列(`names`)の、
各要素(`name`)を処理した後の状態
(`name`と`firstAndLastNames`を処理した結果)を返すことで、
対象の配列を処理している。
関数の引数とその結果にしか影響を与えていないという意味においては、
こちらも「純粋な関数」のみを利用した処理であると言える。  
ただしこのケースにおいては、考えるべきことが一つ多い。
「引数として渡した関数」の第一引数、`firstAndLastNames`の存在だ。  
「reduceを使った場合」では、
第二引数の`name`を「選ぶ」場合にせよ「変換する」場合にせよ、
`firstAndLastNames`に対してどうするのか常に意識せねばならない。  
そのため仮に、

```javascript
// 条件を満たさないので、結果の配列には追加しない。
return firstAndLastNames;
```

の箇所で間違って`firstAndLastNames`を書き忘れてしまった場合、
この関数は正しく動作しない。
引数が多いと、その分意識せねばならない対象が増え、
間違ってしまう可能性も増えるのだ[^type-and-test]。
これでは「mapやfilterを使った場合」に比べて、
予測可能プログラミングする上で好ましくないであろう。

[^type-and-test]:
余談だが、もちろんこのケースは型チェックなりテストなりで未然に防げる間違えである。
が、本記事ではその点は論じない。

# これだけではつまらないので次の予告を少し

<iframe src="http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=poe02-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=4274064069" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
