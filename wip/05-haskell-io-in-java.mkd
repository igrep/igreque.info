---
title: HaskellのIOは他の言語でいうところの関数オブジェクトとよく似てるよ、という話
author: Yuji Yamamoto
date: November 11, 2016
tags: Haskell, Monad, Java
...
---

HaskellのIOは奇妙です。  
「純粋な関数だけでプログラムが書けるの？」と多くの方が疑問に思うように、実際のところ、副作用のある操作（入出力。ファイルの読み書きやネットワーク通信など）をしなければ、役に立つプログラムは一切書けません。  
Haskellではそのものズバリ「IO」という機能を使ってそれを実現します。

しかし一方でHaskellは「純粋」なので副作用が一切ない、とも言われます（例えば[Wikipediaのこの辺の説明](https://ja.wikipedia.org/w/index.php?title=Haskell&oldid=59994146#.E5.85.A5.E5.87.BA.E5.8A.9B)）。  
その辺のややこしい問題について、かの[「プログラミングHaskell」](https://estore.ohmsha.co.jp/titles/978427406781P)の訳者、[山本和彦さんの記事](http://d.hatena.ne.jp/kazu-yamamoto/20090627/1246135829)では、下記のように解説されていました（原文のままコピペしています）。

> Haskell の IO では、評価と実行を分離して考える。例として、以下の関数を考えよう。

>
    ```haskell
    putStr :: String -> IO ()
    ```

> putStr は、たとえば putStr "Hello World" のように、String を引数に渡して評価すると、IO () という型の何かを返す。

> このように IO a という型、念のため言うが -> などを含まない単体の IO a という型を持つものを Hakell ではアクションと呼ぶ。僕には、カタカナを使って説明した気になっている人は説明が下手だという信念があるので、日本語に直そう。単体の IO a という型を持つものとは、命令書である。

> つまり、こういうことだ。putStr "Hello World" は、「"Hello World" を標準出力に出力しろ」という命令書を作る。これが実行されてはじめて、"Hello World" が出力される。

今回はここでいう「命令書」という概念を、他の言語のオブジェクトで例えて説明することで、もっと具体的にとらえ直すということに挑戦したいと思います。  
あ、今回もJavaを使いますが、[前回](/posts/2016/04-monad-in-java.html)以上にJavaへの依存度を下げますので、他のオブジェクト指向な言語で説明してもいいんじゃないんじゃないかなぁもと思います。

# はじめにまとめ

hoge

- Haskellの`IO`は他の言語における「引数をとらない関数オブジェクト」と似てる。
    - ただし、Haskellの`IO`にはプログラマー自らが直接`IO`を実行するAPIがない。
    - プログラマーは原則として、`IO`を「組み合わせる」ことでプログラムを組み立てる。
- Haskellでは関数が入出力を行うかどうかが、型を見るだけで知ることができる。
- なんだか難しいことを書いたけど、結局のところ**見かけ上、Haskellは入出力処理も普通にできると考えた方が分かりやすいからあんまり気にしないでね**！

# 命令「書」

さて、引用した通り、HaskellのIOは命令「書」である、と言えます。  
これはIO（を返す関数）自体は「命令を実行する関数」ではなく命令を表すオブジェクトであるという意味でもあります。  
この記事でいう「オブジェクト」とは「演算の対象になるもの」程度の意味です。[第一級オブジェクト](https://ja.wikipedia.org/wiki/%E7%AC%AC%E4%B8%80%E7%B4%9A%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88)と言い換えてもいいはずでしょう。

つまり、HaskellのIOは「演算の対象になるもの」として変数に格納したり、関数の実行結果として返したり、関数の引数として渡したりできるのです。  
この性質を利用すると、他の言語でよくやる、コールバックのような機能を実現することもできます。Haskellのコードになってしまいますが、一応実例をhogeに置きました。ご興味のあるかたはご覧ください。

さて、「変数に格納したり、関数の実行結果として返したり、関数の引数として渡したりできる」ことに加えてコールバックのような使い方もできる、このようにHaskellのIOをとらえると、なんだか他の言語の関数オブジェクトのようにも思えてきませんか？  
そう、HaskellのIOは、今時な言語ならだいたい実装している、関数オブジェクト（第一級オブジェクトな関数）[^functionObject]とそっくりなのです！

[^functionObject]: 「手続きオブジェクト」と呼ばれたりもします。  
RubyでいうとProcクラスやMethodクラスのオブジェクトであり、C#では「デリゲート」と呼ばれたりもします。

# Haskellの関数オブジェクトとほかの言語の関数オブジェクト

しかし、Haskellはいわゆる「関数型言語」に属している通り、IOに言及するまでもなく、それとは別に「関数オブジェクト」と呼べるものが存在しています。  
そう、「関数型」の値です。これとIOとの違いはいったいなんなのでしょうか。

一番の違いは、やはりHaskellの関数が「純粋」であるところに由来します。  
Haskellの関数型の値は、例えば「`Int -> String`(`Int`型の値を受け取って`String`型の値を返す関数)」という型宣言で表されるのですが、原則として、**その型に書いてあること以上のことはできません**。「`Int -> String`」な関数は文字通り「`Int`型の値を受け取って`String`型の値を返す」以上のことができないのです（主にデバッグ目的で使われる例外はあります）。  
それに対して**`IO`は、これまた文字通り入出力処理など、他のプログラミング言語（の関数オブジェクト）なら自由にできること**の多くができます。  
`IO`を特別扱いすることによって、`IO`する関数かどうかが型を見るだけでわかるようになっているのです。

加えて、他の言語の「関数オブジェクト」やHaskellの「関数型の値」どちらとも大きく異なる点があります。  
**引数をとることができない**のです。引数をとるのは「関数型」の役目、ということになっています。  
例えば、ファイル名を受け取ってそのファイルの中身を読んで返す関数、`readFile`は、以下のような型となっています[^filepath]。

[^filepath]: [実際にドキュメントを読むと](https://hackage.haskell.org/package/base-4.7.0.1/docs/Prelude.html)`readFile`の型は`FilePath -> IO String`となっていますが、`FilePath`は単なる`String`の別名(Rubyで言えばalias)です。

```haskell
readFile :: String -> IO String
```

これは、「`String`（文字列型）を受け取って`IO String`という型を返す関数」という意味です。  
第一引数の`String`はファイル名だとして、はて、`IO String`の`String`というのは一体なんの`String`でしょう？  
これは、`readFile`が返す`IO`（指定された名前のファイルを読み込む関数オブジェクト）を実行した結果
--- すなわちこのケースで言えば読み込んだファイルの中身 --- です。

`IO`はこのように、型引数として「実行した結果の型」を明示することで使用します。  
`IO String`であれば恐らく「ファイルやソケットなどから読んで文字列を返す関数オブジェクト」でしょうし、`IO Bool`であれば例えば「ファイルの有無を調べて、ファイルがあれば`True`, なければ`False`を返す関数オブジェクト」かもしれません。  
Javaに詳しい方は`Callable<String>`などと読み替えていただくとピンと来るでしょう。

# 他の言語の関数オブジェクトとしてのHaskellのIO

さて、上記をより具体的にイメージしやすくするために、Haskellの`IO`っぽいものをJavaで表現してみましょう。  
ここまでに述べた通り、Haskellの`IO`は、他の言語で例えるなら「引数をとらない関数オブジェクトっぽいもの」なので「関数オブジェクトをラップしたクラス」として表現することとします。実際のHaskellの`IO`はプリミティブなものなのでなにかをラップしているなんてことはないのですが、実際に動くサンプルを作るために必要なので、ご了承ください。

```java
public class IO<T1> {
  private final Callable<T1> internalAction;

  IO(Callable<T1> internalAction){
    this.internalAction = internalAction;
  }

  public <T2> IO<T2> plus(IO<T2> nextIo) {
    return new IO<>(() -> {
      this.internalAction.call();
      return nextIo.internalAction.call();
    });
  }

  public <T2> IO<T2> then(Function<T1, IO<T2>> makeNextIo) {
    return new IO<>(() -> {
      T1 result = this.internalAction.call();
      IO<T2> nextIo = makeNextIo.apply(result);
      return nextIo.internalAction.call();
    });
  }

}
```

詳細に立ち入る前に、最も重要な点を述べます。  
このHaskellの`IO`っぽいものを表現したクラス`IO`は、「関数オブジェクト」と似ていながら、「関数オブジェクト」として**直接実行するAPI[^call-other-languages]を利用者に提供していない**のです。  
それを表すために今回は、ラップした関数オブジェクト(`internalAction`)を`private`にして、`internalAction`を呼び出すメソッド(`call`)を直接呼べないようにしました。  
**Haskellでは`IO`は「実行するもの」ではなくあくまでも「組み合わせる」もの**であり、後に示します「組み合わせる」ための関数（上記のクラスのメソッド）を用いてのみ操作します。

[^call-other-languages]: Javaの`Callable`やRubyの`Proc`で言えば文字通り`call`メソッド、JavaScriptやPythonの関数オブジェクトで言えば関数呼び出し演算子 `()`がそれに該当します。

## `IO`を組み合わせる関数

### 単純に繋げる: `plus`メソッド

最初に単純な`plus`メソッドについて説明しましょう [^haskell-plus]。

[^haskell-plus]: この`plus`メソッドはHaskellでいうところの`>>`関数です。

```java
  public <T2> IO<T2> plus(IO<T2> nextIo) {
    return new IO<>(() -> {
      this.internalAction.call();
      return nextIo.internalAction.call();
    });
  }
```

`plus`メソッドは`return new IO<>()`している通り、新しく`IO`を作って返します。`IO`は関数オブジェクトをラップしたものなので、新しく別の関数オブジェクトを作って渡す必要があります。  
その、新しく作った関数オブジェクトでは何をしているのでしょう？  
最初に`plus`メソッドを呼んだ`IO`オブジェクト自身を呼び出し(`this.internalAction.call()`)、次に引数として渡された`IO`オブジェクトを呼び出す(`nextIo.internalAction.call()`)、ただそれだけです。  
まとめると、「`plus`メソッドを呼び出した`IO`と、引数として与えられた`IO`を**続けて呼び出す新しい`IO`を作る**」、ただそれだけです[^cs-plus]。

[^cs-plus]: 実はこの`plus`メソッド、C#によく似た振る舞いをする演算子があります。名前の通り足し算に使っている`+`演算子です（`plus`メソッドという名前もそこからとりました）。  
C#では関数オブジェクト（デリゲート）同士を`+`で繋ぐことで、両辺の関数オブジェクトを「続けて実行する」新しい関数オブジェクトを作ることができます。詳細は[MSDNのこちらのページ](https://msdn.microsoft.com/ja-jp/library/ms173175.aspx)などをご覧ください。

### 結果を再利用できるようにしつつ繋げる: `then`メソッド

続けて、もうちょっと複雑な`then`メソッドを紹介しましょう [^haskell-then]。

[^haskell-then]: `then`メソッドはHaskellでいうところのあの`>>=`関数です。今回はMonad自体の話はしませんが、これは[前回](/posts/2016/04-monad-in-java.html)`Monad`のメソッドとして作成した`then`メソッドを`IO`が実装したバージョンです。`IO`は`Monad`インターフェースを実装したクラス（Haskellの用語で言えば「`Monad`型クラスのインスタンス」）なのです。

```java
  public <T2> IO<T2> then(Function<T1, IO<T2>> makeNextIo) {
    return new IO<>(() -> {
      T1 result = this.internalAction.call();
      IO<T2> nextIo = makeNextIo.apply(result);
      return nextIo.internalAction.call();
    });
  }
```

まずは`plus`メソッドと同じ部分を列挙します。

1. `plus`メソッドと同様、`return new IO<>()`している通り、新しく`IO`を作って返す。  
  なので`IO`に渡す関数オブジェクトの中で`IO`を組み合わせることとなる。
1. `plus`メソッドと同様、最初に`then`メソッドを呼んだ`IO`オブジェクト自身を呼び出し(`this.internalAction.call()`)、次にもう1つの`IO`オブジェクトを呼び出す(`nextIo.internalAction.call()`)。

大きく異なる点は、`plus`メソッドが`IO<T2> nextIo`を直接受け取っていたのに対して、`then`メソッドが`Function<T1, IO<T2>> makeNextIo`、すなわち「`nextIo`を作る関数」を受けとることに起因します。  
`makeNextIo`は、`plus`メソッドでは無視していた「呼び出しもとの`IO`の実行結果(`this.internalAction.call()`)」を受けとる(`makeNextIo.apply(result)`)ことで初めて`nextIo`を返します。  
そして`makeNextIo`が返した`IO`を実行してその結果を返す --- というのが`then`メソッドが作る`IO`の処理の流れです。  
まとめると、「`then`メソッドを呼び出した`IO`の**結果を使って**引数として与えられた`IO`を作り、それらを**続けて呼び出す新しい`IO`を作る**」、ということとなります。

この後の例でも触れますが、`then`メソッドは、例えばファイル名をユーザーの入力から受け取って、そのファイルを読み込むといった`IO`アクションを作りたいときに使用されます。  
「『ファイル名をユーザーから受けとる`IO`』の結果を用いた『ファイルを読み込む`IO`』」を作る場合は、`plus`メソッドの機能では限界があり、`then`メソッドのような機能が必要となるのです。

# 何が嬉しいの？

さて、ここまでHaskellの`IO`についてJavaのクラスで例えてきました。  
その結果、Haskellでは`IO`は「実行するもの」ではなくあくまでも「組み合わせる」ものであり、`plus`メソッドや`then`メソッドのような、組み合わせるためのAPIを用いてのみ操作する、ということがわかりました。  
一体なぜ、そのような変わった仕様になっているのでしょうか。

実用的な観点のみに触れるならば、それは`IO`に対して何らかの処理を加えた結果は必ず`IO`になるので、結果として**全ての入出力処理には`IO`という型がつけられる**、という点でしょう。  
`plus`メソッドのシグネチャが`IO<T2> plus(IO<T2> nextIo)`、`then`メソッドのシグネチャが`IO<T2> then(Function<T1, IO<T2>> makeNextIo)`である通り、`IO`を組み合わせるメソッドはいずれも`IO<T2>`の値を返すようになっています。  
そして、前の節で触れたように、`IO`は他のプログラミング言語の関数オブジェクトと異なり、(`Callable`の`call`メソッドのような)「直接実行するAPI」を提供していません。  
更に加えて、Haskellでは標準で提供される、あらゆる入出力処理がこの`IO`型の値（あるいは`IO`型の値を返す関数）となっています。  
したがってHaskellにおいて、ある関数が入出力処理をしうるかどうかは、関数が`IO`型の値を返すかどうかだけを見ればわかる、あるいは、**関数の型を見るだけで入出力処理をするかどうかがわかる**ということとなります（主にデバッグ目的に作られた例外はあります）。

このことは「入出力処理とそれ以外の処理を、意識して分割させやすくする」という大きなメリットをもたらします。  
一般に、入出力を伴うコードはテストしにくいコードです。特定のディレクトリーにおかれた特定のパーミッションのファイルがなければ動かないコードかもしれませんし、データベースに接続しなければ動かないコードかもしれません。更には一度実行したらファイルを削除しなければならないかもしれませんし、データベースを特定の状態にロールバックしなければならないかもしれません。  
そうしたコードとそうでないコードを区別させることは、自然とコード全体のテストしやすさを高めることにも繋がりますし、例え入出力を伴うコードが適切に分割されていなかったとしても、そのことを型宣言から容易に測り知ることができます。  
静的型付け言語のメリットとして、型宣言を書くことがそのまま常時up-to-dateなドキュメントになる、ということが挙げられますが、Haskellはそうした特徴をもう一歩踏み込んで活用しているのです。「関数が入出力処理を行う」ということを型宣言に含めることで、関数の役割を常に明確にすることができるようになっているのです。

# 純粋な関数とIOしかない世界

hoge: 長い上この記事で本当に言いたいことが遠回しになってしまうので、省略する？

続いて、「Haskellでは`IO`は『実行するもの』ではなくあくまでも『組み合わせる』もの」という認識をより実感していただくために、先ほどJavaで作った`IO`を実際に使ってみましょう。Haskellの（純粋な）関数をJavaの`Function`で、`IO`を先ほど作ったJavaの`IO`に例えて、Haskellのプログラム(Main モジュール)の世界観を再現してみます。  
この節では最終的な目標として、普通のJavaで書けば下記のようなコードになるプログラムを、「純粋な関数とIOしかない世界」観で翻訳することを目指します。

```java
public class IOSampleInOrdinaryJava {
  public static void main(String args[]) throws Exception {
    // 挨拶のあと、名前を尋ねて、
    System.out.println("Nice to meet you!");
    System.out.println("May I have your name? ");

    // 標準入力から名前を取得して、
    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    String name = reader.readLine();

    // 名前を誉める
    System.out.println("Your name is " + name + "?");
    System.out.println("Nice name!");
  }
}
```

※上記を含め[この節に載せたコードはこちらhoge](hoge: 試しやすいよう、独立したリポジトリーに移す)にあります。全体像に興味のあるかたはどうぞ。

入門書の最初の方に載っていそうな、「ユーザーの名前を（標準入力から）聞いて、名前を誉めつつ画面に表示する」だけのプログラムです。  
これを`Function`と`IO`だけで再現すると、下記のようになります... と、言いたいところですが、その前に一つ重要なパーツを作っておく必要があります。  
`System.out.println`などの、Javaの普通の入出力処理を先ほど作った`IO`でラップしておきましょう。  
Haskellの世界には`IO`と純粋な関数しかないのですから、それを表現するにはJavaの普通の入出力処理をすべて`IO`で隠蔽して、プログラマーが直接使わなくてもいいようにしておかなければなりません。

## Prelude.java

と、いうわけで作ったのが下記の`Prelude.java`です。  
`Prelude`というのはHaskellが標準で提供してくれるモジュールの一つで、明示的に`import`しなくても使えるようになっています。Javaで言えば`java.lang` パッケージ、Pythonで言えば`__builtin__` モジュールのようなものですね。  
`Prelude.java`が提供する定数の名前も、Haskellの`Prelude` モジュールに合わせています [^prelude-haskell]。

[^prelude-haskell]: もちろん、実際のHaskellの`Prelude` モジュールはもっとたくさんの関数を提供します。

```java
public class Prelude {
  public static final Function<String, IO<Void>> putStrLn =
    (string) -> new IO<>(() -> {
      System.out.println(string);
      return null;
    });

  public static final IO<String> getLine =
    new IO<>(() -> {
      BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
      return reader.readLine();
    });
}
```

ご覧の通り、上記の`Prelude`クラスには`static final`な定数しか定義されておりません。  
これは、HaskellにはJavaで言うところのクラスやオブジェクトの区別がないため、ローカル変数に格納されるものを除き、全ての値はstatic finalな定数に格納されると例えた方が、より実態に近いのではないか、と考えたためです。  
なお、当たり前ですが、みなさんが実際にHaskellのコードをJavaに翻訳する（という悲しい機会）に出くわしたとしても、こんな効率の悪い翻訳はしないでくださいね。普通に関数はメソッドに変えて、`IO`は使わず直接入出力処理をしましょう。

ともあれ、`Prelude`が提供する各定数について解説しましょう。  
まずは`Prelude.putStrLn`です。内部で`System.out.println`を使っている通り、標準出力に文字列を書き込むために使います。  
「Haskellの（純粋な）関数をJavaの`Function`で、`IO`を先ほど作ったJavaの`IO`に」例えるのが今回のミッションなので、出力する文字列は、`Function`の引数として受けとります。  
これによって、`putStrLn`は「引数として文字列を与えると、文字列を標準出力に書き込む**関数オブジェクトを返す純粋な関数**」であることが明確になりました。  
なので`putStrLn`は、次のように使います。

```java
import static Prelude.putStrLn;

...

IO<Void> action = putStrLn.apply("Hello,");

// action.plusメソッドやを呼び出して、後続の IO を追加したりする。
IO<Void> action2 = action.plus(PutStrLn.apply("world!"));
// action2は「Hello,」という行の後に「world!」という行を出力するIOとなる
```

`putStrLn`は`Function`なので、引数を与えて実行する際は`apply`メソッドを使います。ちょっと不格好ですが、まぁ、あくまでもJavaで強引に例えた場合の話なので...。  
それはさておき、ここで強調しておきたいことが一点あります。  
`putStrLn.apply("Hello, world!")`が返す値はあくまでも関数オブジェクト(`IO`)なので、`putStrLn.apply("Hello, world!")`という式は副作用を持ちません。  
そしてプログラマーは`putStrLn`が返した**関数オブジェクト(`IO`)を「組み合わせる」ことでしか使用できない**のです[^call-io]。  
その結果Haskellでは、プログラマーが書ける範囲内においては、すべての関数が形式上純粋な関数となるのです。

[^call-io]: 今回Javaで書いたサンプルで、実際に組み合わせた`IO`を呼び出す部分はhogeにあります。  
試しに`putStrLn`などの組み合わせかたを変更してみて、動作を確認するのもよいかもしれません。

hoge: 「関数オブジェクト(`IO`)」と「`IO`オブジェクト」と「`IO`」という表現の使い分け  
続いて、`Prelude.getLine`です。標準入力から一行取得する関数オブジェクト(`IO`)です。Javaの標準には一つのメソッドでそれに相当するものはないようですが、他の言語でもお馴染みの関数ですよね。

```java
public class Prelude {
  // ... 省略 ...

  public static final IO<String> getLine =
    new IO<>(() -> {
      BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
      return reader.readLine();
    });
}
```

`putStrLn`と異なり、`getLine`は`Function`ではなく単なる`IO`です。そのため引数をなにもうけとりません。  
取得する文字列はあくまでも「標準入力から」であって、引数からではないのです。

取得した文字列はどのように使うのでしょうか？  
これもやはり`getLine`と他の`IO`オブジェクトを「組み合わせる」ことで行います。

```java
import static Prelude.getLine;
import static Prelude.putStrLn;

...

IO<Void> echo =
  getLine.then((line) ->
    putStrLn.apply(line)
  );
```

`getLine`が標準入力から取得した文字列は、`then`メソッドに渡した関数に渡されます。  
`then`メソッドに渡した関数は`getLine`が取得した文字列（上記の場合`line`変数）にアクセスできるので、それを使ってまた別の`IO`オブジェクトを作ることができます。  
上記の例の場合は、`putStrLn`関数にそのままそれを渡すことにしました。結果、組み合わせてできた`IO`オブジェクト `echo` は、「標準入力から文字列を1行受け取って、受け取った文字列をそのまま標準出力に書き込む関数オブジェクト」となります。

## IOでもっと大きなサンプルを作る

それではいよいよ、`Prelude,java`で定義した各種`IO`を利用して、この節冒頭の「ユーザーの名前を（標準入力から）聞いて、名前を誉めつつ画面に表示する」だけのプログラムを`IO`で翻訳しましょう。  

```java
/**
 * {@code IO} を使用した、単純なサンプルプログラム。
 * Haskellでプログラムを書く際、プログラマーは下記のように、
 * {@code Prelude} などで定義した各種IO型の値（putStrLn, getLine）を
 * 「組み合わせる」ことでmainを作る。
 */

public class IOSample {
  /**
   * プログラマーが作る、実際にHaskellの処理系が実行するプログラムの中身。
   * CやJavaなどと似たように、mainという名前で宣言された関数
   * (Haskellの場合はIOオブジェクト)が実行される。
   *
   */
  public static final IO<Void> main =
    putStrLn.apply("Nice to meet you!")
      .plus(
        putStrLn.apply("May I have your name? ")
      )
      .plus(
        getLine
          .then((name) ->
            putStrLn.apply("Your name is " + name + "?")
              .plus(putStrLn.apply("Nice name!"))
          )
      );
}
```

hoge

普通は絶対やらないスタイルなので、当然ながら冗長で実用的な書き方ではありません。  
もちろんHaskellのプログラム（moduleと呼んだ方が適切ですかね）は、それに特化された文法で、これより遥かにスッキリ書かれているという点はお忘れなく。[このプログラムのHaskell版についてはhogeこちら](hoge: https://github.com/igrep/haskell-io-in-java/src/main/hs/io-sample.hs)をご覧ください。

hoge

# それで結局Haskellは副作用がある式を書けるの？書けないの？

Haskellの`IO`はあくまでも「組み合わせる」

hoge

# 参考

hoge


