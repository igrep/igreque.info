---
title: HaskellのIOは他の言語でいうところの関数オブジェクトとよく似てるよ、という話
author: Yuji Yamamoto
date: November 11, 2016
tags: Haskell, Monad, Java
...
---

HaskellのIOは奇妙です。  
「純粋な関数だけでプログラムが書けるの？」と多くの方が疑問に思うように、実際のところ、副作用のある操作（入出力。ファイルの読み書きやネットワーク通信など）をしなければ、役に立つプログラムは一切書けません。  
Haskellではそのものズバリ「IO」という機能を使ってそれを実現します。

しかし一方でHaskellは「純粋」なので副作用が一切ない、とも言われます（例えば[Wikipediaのこの辺の説明](https://ja.wikipedia.org/w/index.php?title=Haskell&oldid=59994146#.E5.85.A5.E5.87.BA.E5.8A.9B)）。  
その辺のややこしい問題について、かの[「プログラミングHaskell」](https://estore.ohmsha.co.jp/titles/978427406781P)の訳者、[山本和彦さんの記事](http://d.hatena.ne.jp/kazu-yamamoto/20090627/1246135829)では、下記のように解説されていました（原文のままコピペしています）。

> Haskell の IO では、評価と実行を分離して考える。例として、以下の関数を考えよう。

>
    ```haskell
    putStr :: String -> IO ()
    ```

> putStr は、たとえば putStr "Hello World" のように、String を引数に渡して評価すると、IO () という型の何かを返す。

> このように IO a という型、念のため言うが -> などを含まない単体の IO a という型を持つものを Hakell ではアクションと呼ぶ。僕には、カタカナを使って説明した気になっている人は説明が下手だという信念があるので、日本語に直そう。単体の IO a という型を持つものとは、命令書である。

> つまり、こういうことだ。putStr "Hello World" は、「"Hello World" を標準出力に出力しろ」という命令書を作る。これが実行されてはじめて、"Hello World" が出力される。

今回はここでいう「命令書」という概念を、他の言語のオブジェクトで例えて説明することで、もっと具体的にとらえ直すということに挑戦したいと思います。  
あ、今回もJavaを使いますが、[前回](/posts/2016/04-monad-in-java.html)以上にJavaへの依存度を下げますので、他のオブジェクト指向な言語で説明してもいいんじゃないんじゃないかなぁもと思います。

# はじめにまとめ

hoge

- Haskellの`IO`は他の言語における「引数をとらない関数オブジェクト」と似てる。
- ただし、Haskellの`IO`にはプログラマー自らが直接`IO`を実行するAPIがない。
- Haskellでは関数が入出力を行うかどうかが、型を見るだけでしることができる。
- なんだか難しいことを書いたけど、結局のところ見かけ上、Haskellは入出力処理も普通にできると考えた方が分かりやすい。

# 命令「書」

さて、引用した通り、HaskellのIOは命令「書」である、と言えます。  
これはIO（を返す関数）自体は「命令を実行する関数」ではなく命令を表すオブジェクトであるという意味でもあります。  
この記事でいう「オブジェクト」とは「演算の対象になるもの」程度の意味です。[第一級オブジェクト](https://ja.wikipedia.org/wiki/%E7%AC%AC%E4%B8%80%E7%B4%9A%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88)と言い換えてもいいはずでしょう。

つまり、HaskellのIOは「演算の対象になるもの」として変数に格納したり、関数の実行結果として返したり、関数の引数として渡したりできるのです。  
この性質を利用すると、他の言語でよくやる、コールバックのような機能を実現することもできます。Haskellのコードになってしまいますが、一応実例をhogeに置きました。ご興味のあるかたはご覧ください。

さて、「変数に格納したり、関数の実行結果として返したり、関数の引数として渡したりできる」ことに加えてコールバックのような使い方もできる、このようにHaskellのIOをとらえると、なんだか他の言語の関数オブジェクトのようにも思えてきませんか？  
そう、HaskellのIOは、今時な言語ならだいたい実装している、関数オブジェクト（第一級オブジェクトな関数）[^functionObject]とそっくりなのです！

[^functionObject]: 「手続きオブジェクト」と呼ばれたりもします。  
RubyでいうとProcクラスやMethodクラスのオブジェクトであり、C#では「デリゲート」と呼ばれたりもします。

# Haskellの関数オブジェクトとほかの言語の関数オブジェクト

しかし、Haskellはいわゆる「関数型言語」に属している通り、IOに言及するまでもなく、それとは別に「関数オブジェクト」と呼べるものが存在しています。  
そう、「関数型」の値です。これとIOとの違いはいったいなんなのでしょうか。

一番の違いは、やはりHaskellの関数が「純粋」であるところに由来します。  
Haskellの関数型の値は、例えば「`Int -> String`(`Int`型の値を受け取って`String`型の値を返す関数)」という型宣言で表されるのですが、原則として、**その型に書いてあること以上のことはできません**。「`Int -> String`」な関数は文字通り「`Int`型の値を受け取って`String`型の値を返す」以上のことができないのです（主にデバッグ目的で使われる例外はあります）。  
それに対して**`IO`は、これまた文字通り入出力処理など、他のプログラミング言語（の関数オブジェクト）なら自由にできること**の多くができます。  
`IO`を特別扱いすることによって、`IO`する関数かどうかが型を見るだけでわかるようになっているのです。

加えて、他の言語の「関数オブジェクト」やHaskellの「関数型の値」どちらとも大きく異なる点があります。  
**引数をとることができない**のです。引数をとるのは「関数型」の役目、ということになっています。  
例えば、ファイル名を受け取ってそのファイルの中身を読んで返す関数、`readFile`は、以下のような型となっています[^filepath]。

[^filepath]: [実際にドキュメントを読むと](https://hackage.haskell.org/package/base-4.7.0.1/docs/Prelude.html)`readFile`の型は`FilePath -> IO String`となっていますが、`FilePath`は単なる`String`の別名(Rubyで言えばalias)です。  
個人的に別名をつけるのはあまり好きじゃないのですが、まぁこれで普及してしまっているので仕方ありませんね...。

```haskell
readFile :: String -> IO String
```

これは、「`String`（文字列型）を受け取って`IO String`という型を返す関数」という意味です。  
第一引数の`String`はファイル名だとして、はて、`IO String`の`String`というのは一体なんの`String`でしょう？  
これは、`readFile`が返す`IO`（指定された名前のファイルを読み込む関数オブジェクト）を実行した結果
--- すなわちこのケースで言えば読み込んだファイルの中身 --- です。

`IO`は通常このように、型引数として「実行した結果の型」を明示することで使用します。  
`IO String`であれば恐らく「ファイルやソケットなどから読んで文字列を返す関数オブジェクト」でしょうし、`IO Bool`であれば例えば「ファイルの有無を調べて、ファイルがあれば`True`, なければ`False`を返す関数オブジェクト」かもしれません。  
Javaに詳しい方は`Callable<String>`などと読み替えていただくとピンと来るでしょう。

# 他の言語の関数オブジェクトとしてのHaskellのIO

さて、上記をより具体的にイメージしやすくするために、Haskellの`IO`っぽいものをJavaで表現してみましょう。  
ここまでに述べた通り、Haskellの`IO`は、他の言語で例えるなら「引数をとらない関数オブジェクトっぽいもの」なので「関数オブジェクトをラップしたクラス」として表現することとします。実際のHaskellの`IO`はプリミティブなものなのでなにかをラップしているなんてことはないのですが、実際に動くサンプルを作るために必要なので、ご了承ください。

```java
public class IO<T1> {
  private final Callable<T1> internalAction;

  IO(Callable<T1> internalAction){
    this.internalAction = internalAction;
  }

  public <T2> IO<T2> plus(IO<T2> nextIo) {
    return new IO<>(() -> {
      this.internalAction.call();
      return nextIo.internalAction.call();
    });
  }

  public <T2> IO<T2> then(Function<T1, IO<T2>> makeNextIo) {
    return new IO<>(() -> {
      T1 result = this.internalAction.call();
      IO<T2> nextIo = makeNextIo.apply(result);
      return nextIo.internalAction.call();
    });
  }

}
```

詳細に立ち入る前に、最も重要な点を述べます。  
このHaskellの`IO`っぽいものを表現したクラス`IO`は、「関数オブジェクト」と似ていながら、「関数オブジェクト」として**直接実行するAPI[^call-other-languages]を利用者に提供していない**のです。  
それを表すために今回は、ラップした関数オブジェクト(`internalAction`)を`private`にして、`internalAction`を呼び出すメソッド(`call`)を直接呼べないようにしました。  
**Haskellでは`IO`は「実行するもの」ではなくあくまでも「組み合わせる」もの**であり、後に示します「組み合わせる」ための関数（上記のクラスのメソッド）を用いてのみ操作します。

[^call-other-languages]: Javaの`Callable`やRubyの`Proc`で言えば文字通り`call`メソッド、JavaScriptやPythonの関数オブジェクトで言えば`()`演算がそれに該当します。

## `IO`を組み合わせる関数

### 単純に繋げる: `plus`メソッド

最初に単純な`plus`メソッドについて説明しましょう [^haskell-plus]。

[^haskell-plus]: この`plus`メソッドはHaskellでいうところの`>>`関数です。

```java
  public <T2> IO<T2> plus(IO<T2> nextIo) {
    return new IO<>(() -> {
      this.internalAction.call();
      return nextIo.internalAction.call();
    });
  }
```

`plus`メソッドは`return new IO<>()`している通り、新しく`IO`を作って返します。`IO`は関数オブジェクトをラップしたものなので、新しく別の関数オブジェクトを作って渡す必要があります。  
その、新しく作った関数オブジェクトでは何をしているのでしょう？  
最初に`plus`メソッドを呼んだ`IO`オブジェクト自身を呼び出し(`this.internalAction.call()`)、次に引数として渡された`IO`オブジェクトを呼び出す(`nextIo.internalAction.call()`)、ただそれだけです。  
まとめると、「`plus`メソッドを呼び出した`IO`と、引数として与えられた`IO`を**続けて呼び出す新しい`IO`を作る**」、ただそれだけです[^cs-plus]。

[^cs-plus]: 実はこの`plus`メソッド、C#によく似た振る舞いをする演算子があります。名前の通り足し算に使っている`+`演算子です（`plus`メソッドという名前もそこからとりました）。  
C#では関数オブジェクト（デリゲート）同士を`+`で繋ぐことで、両辺の関数オブジェクトを「続けて実行する」新しい関数オブジェクトを作ることができます。詳細は[MSDNのこちらのページ](https://msdn.microsoft.com/ja-jp/library/ms173175.aspx)などをご覧ください。

### 結果を再利用できるようにしつつ繋げる: `then`メソッド

続けて、もうちょっと複雑な`then`メソッドを紹介しましょう [^haskell-then]。

[^haskell-then]: `then`メソッドはHaskellでいうところのあの`>>=`関数です。今回はMonad自体の話はしませんが、これは[前回](/posts/2016/04-monad-in-java.html)`Monad`のメソッドとして作成した`then`メソッドを`IO`が実装したバージョンです。`IO`は`Monad`インターフェースを実装したクラス（Haskellの用語で言えば「`Monad`型クラスのインスタンス」）なのです。

```java
  public <T2> IO<T2> then(Function<T1, IO<T2>> makeNextIo) {
    return new IO<>(() -> {
      T1 result = this.internalAction.call();
      IO<T2> nextIo = makeNextIo.apply(result);
      return nextIo.internalAction.call();
    });
  }
```

まずは`plus`メソッドと同じ部分を列挙します。

1. `plus`メソッドと同様、`return new IO<>()`している通り、新しく`IO`を作って返す。  
  なので`IO`に渡す関数オブジェクトの中で`IO`を組み合わせることとなる。
1. `plus`メソッドと同様、最初に`then`メソッドを呼んだ`IO`オブジェクト自身を呼び出し(`this.internalAction.call()`)、次にもう1つの`IO`オブジェクトを呼び出す(`nextIo.internalAction.call()`)。

大きく異なる点は、`plus`メソッドが`IO<T2> nextIo`を直接受け取っていたのに対して、`then`メソッドが`Function<T1, IO<T2>> makeNextIo`、すなわち「`nextIo`を作る関数」を受けとることに起因します。  
`makeNextIo`は、`plus`メソッドでは無視していた「呼び出しもとの`IO`の実行結果(`this.internalAction.call()`)」を受けとる(`makeNextIo.apply(result)`)ことで初めて`nextIo`を返します。  
そして`makeNextIo`が返した`IO`を実行してその結果を返す --- というのが`then`メソッドが作る`IO`の処理の流れです。  
まとめると、「`then`メソッドを呼び出した`IO`の**結果を使って**引数として与えられた`IO`を作り、それらを**続けて呼び出す新しい`IO`を作る**」、ということとなります。

この後の例でも触れますが、`then`メソッドは、例えばファイル名をユーザーの入力から受け取って、そのファイルを読み込むといった`IO`アクションを作りたいときに使用されます。  
「『ファイル名をユーザーから受けとる`IO`』の結果を用いた『ファイルを読み込む`IO`』」を作る場合は、`plus`メソッドの機能では限界があり、`then`メソッドのような機能が必要となるのです。

# 何が嬉しいの？

さて、ここまでHaskellの`IO`についてJavaのクラスで例えてきました。  
その結果、Haskellでは`IO`は「実行するもの」ではなくあくまでも「組み合わせる」ものであり、`plus`メソッドや`then`メソッドのような、組み合わせるためのAPIを用いてのみ操作する、ということがわかりました。  
一体なぜ、そのような変わった仕様になっているのでしょうか。

実用的な観点のみに触れるならば、それは`IO`に対して何らかの処理を加えた結果は必ず`IO`になるので、結果として**全ての入出力処理には`IO`という型がつけられる**、という点でしょう。  
`plus`メソッドのシグネチャが`IO<T2> plus(IO<T2> nextIo)`、`then`メソッドのシグネチャが`IO<T2> then(Function<T1, IO<T2>> makeNextIo)`である通り、`IO`を組み合わせるメソッドはいずれも`IO<T2>`の値を返すようになっています。  
そして、前の節で触れたように、`IO`は他のプログラミング言語の関数オブジェクトと異なり、(`Callable`の`call`メソッドのような)「直接実行するAPI」を提供していません。  
更に加えて、Haskellでは標準で提供される、あらゆる入出力処理がこの`IO`型の値（あるいは`IO`型の値を返す関数）となっています。  
したがってHaskellにおいて、ある関数が入出力処理をしうるかどうかは、関数が`IO`型の値を返すかどうかだけを見ればわかる、あるいは、**関数の型を見るだけで入出力処理をするかどうかがわかる**ということとなります（主にデバッグ目的に作られた例外はあります）。

このことは「入出力処理とそれ以外の処理を、意識して分割させやすくする」という大きなメリットをもたらします。  
一般に、入出力を伴うコードはテストしにくいコードです。特定のディレクトリーにおかれた特定のパーミッションのファイルがなければ動かないコードかもしれませんし、データベースに接続しなければ動かないコードかもしれません。更には一度実行したらファイルを削除しなければならないかもしれませんし、データベースを特定の状態にロールバックしなければならないかもしれません。  
そうしたコードとそうでないコードを区別させることは、自然とコード全体のテストしやすさを高めることにも繋がりますし、例え入出力を伴うコードが適切に分割されていなかったとしても、そのことを型宣言から容易に測り知ることができます。  
静的型付け言語のメリットとして、型宣言を書くことがそのまま常時up-to-dateなドキュメントになる、ということが挙げられますが、このようにHaskellはこの特徴をもう一歩踏み込んで活用しています。  
「関数が入出力処理を行う」ということが

hoge

# 純粋な関数とIOしかない世界


# 参考

hoge


