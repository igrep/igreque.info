---
title: HaskellのIOは他の言語でいうところの関数オブジェクトだという話
author: Yuji Yamamoto
date: October 25, 2016
tags: Haskell, Monad, Java
...
---

HaskellのIOは奇妙です。  
「純粋な関数だけでプログラムが書けるの？」と多くの方が疑問に思うように、実際のところ、副作用のある操作（入出力。ファイルの読み書きやネットワーク通信など）をしなければ、役に立つプログラムは一切書けません。  
Haskellではそのものズバリ「IO」という機能を使ってそれを実現します。

しかし一方でHaskellは「純粋」なので副作用が一切ない、とも言われます（例えば[Wikipediaのこの辺の説明](https://ja.wikipedia.org/w/index.php?title=Haskell&oldid=59994146#.E5.85.A5.E5.87.BA.E5.8A.9B)）。  
その辺のややこしい問題についてかの[「プログラミングHaskell」](https://estore.ohmsha.co.jp/titles/978427406781P)の訳者、[山本和彦さんの記事](http://d.hatena.ne.jp/kazu-yamamoto/20090627/1246135829)では、下記のように解説されていました（原文のままコピペしています）。

> Haskell の IO では、評価と実行を分離して考える。例として、以下の関数を考えよう。

>
    ```haskell
    putStr :: String -> IO ()
    ```

> putStr は、たとえば putStr "Hello World" のように、String を引数に渡して評価すると、IO () という型の何かを返す。

> このように IO a という型、念のため言うが -> などを含まない単体の IO a という型を持つものを Hakell ではアクションと呼ぶ。僕には、カタカナを使って説明した気になっている人は説明が下手だという信念があるので、日本語に直そう。単体の IO a という型を持つものとは、命令書である。

> つまり、こういうことだ。putStr "Hello World" は、「"Hello World" を標準出力に出力しろ」という命令書を作る。これが実行されてはじめて、"Hello World" が出力される。

今回はここでいう「命令書」という概念を、他の言語のオブジェクトで例えて説明することで、もっと具体的にとらえ直すということに挑戦したいと思います。  
hogeあ、今回もJavaを使いますが、[前回](/posts/2016/04-monad-in-java.html)以上にJavaへの依存度を下げますので、他のオブジェクト指向な言語で説明してもいいんじゃないんじゃないかなぁもと思います。

# はじめにまとめ

hoge

# 命令「書」

さて、引用した通り、HaskellのIOは命令「書」である、と言えます。  
これはIO（を返す関数）自体は「命令を実行する関数」ではなく命令を表すオブジェクトであるという意味でもあります。  
この記事でいう「オブジェクト」とは「演算の対象になるもの」程度の意味です。[第一級オブジェクト](https://ja.wikipedia.org/wiki/%E7%AC%AC%E4%B8%80%E7%B4%9A%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88)と言い換えてもいいはずでしょう。

つまり、HaskellのIOは「演算の対象になるもの」として変数に格納したり、関数の実行結果として返したり、関数の引数として渡したりできるのです。  
この性質を利用すると、他の言語でよくやる、コールバックのような機能を実現することもできます。  
Haskellのコードになってしまいますが、一応実例をhogeに置きました。ご興味のあるかたはご覧ください。

```haskell
main :: IO ()
main = do
  let fileReader =
        FileReader
          { path = "fileReader.hs"
          , onOpened = 
          , onClosed = 
          }

   content <- readBy fileReader
   putStrLn "The content was:"
   putStrLn content
```

さて、「変数に格納したり、関数の実行結果として返したり、関数の引数として渡したりできる」ことに加えてコールバックのような使い方もできる、このようにHaskellのIOをとらえると、なんだか他の言語の関数オブジェクトのようにも思えてきませんか？  
そう、HaskellのIOは、今時な言語ならだいたい実装している、関数オブジェクト（第一級オブジェクトな関数）[^functionObject]とそっくりなのです！

[^functionObject]: 「手続きオブジェクト」と呼ばれたりもします。  
RubyでいうとProcクラスやMethodクラスのオブジェクトであり、C#やVB.NETでは「デリゲート」と呼ばれたりもします。

# Haskellの関数オブジェクトとほかの言語の関数オブジェクト

しかし、Haskellはいわゆる「関数型言語」に属している通り、IOに言及するまでもなく、それとは別に「関数オブジェクト」と呼べるものが存在しています。  
そう、「関数型」の値です。これとIOとの違いはいったいなんなのでしょうか。

一番の違いは、やはりHaskellの関数が「純粋」であるところに由来します。  
Haskellの関数型の値は、例えば「`Int -> String`(`Int`型の値を受け取って`String`型の値を返す関数)」という型宣言で表されるのですが、原則として、**その型に書いてあること以上のことはできません**。「`Int -> String`」な関数は文字通り「`Int`型の値を受け取って`String`型の値を返す」以上のことができないのです（主にデバッグ目的で使われる例外はあります）。  
それに対して**`IO`は、これまた文字通り入出力処理など、他のプログラミング言語（の関数オブジェクト）なら自由にできること**の多くができます。  
`IO`を特別扱いすることによって、`IO`する関数かどうかが型を見るだけでわかるようになっているのです。

加えて、「関数オブジェクト」や「関数型の値」どちらとも大きく異なる点があります。  
**引数をとることができない**のです。引数をとるのは「関数型」の役目、ということになっています。  
例えば、ファイル名を受け取ってそのファイルの中身を読んで返す関数、`readFile`は、以下のような型となっています[^filepath]。

[^filepath]: [実際にドキュメントを読むと](https://hackage.haskell.org/package/base-4.7.0.1/docs/Prelude.html)`readFile`の型は`FilePath -> IO String`となっていますが、`FilePath`は単なる`String`の別名(Rubyで言えばalias)です。  
個人的に別名をつけるのはあまり好きじゃないのですが、まぁこれで普及してしまっているので仕方ありませんね...。

```haskell
readFile :: String -> IO String
```

これは、「`String`（文字列型）を受け取って`IO String`という型を返す関数」という意味です。  
第一引数の`String`はファイル名だとして、はて、`IO String`というのはなんでしょう？  
これは、`readFile`が返す`IO`（指定された名前のファイルを読み込む関数オブジェクト）を実行した結果
--- すなわちこのケースで言えば読み込んだファイルの中身 --- です。

`IO`は通常このように、型引数として「実行した結果の型」を明示することで使用します。  
`IO String`であれば恐らく「ファイルやソケットなどから読んで文字列を返す関数オブジェクト」でしょうし、`IO Bool`であれば例えば「ファイルの有無を調べてあれば`True`, なければ`False`を返す関数オブジェクト」かもしれません。  
Javaに詳しい方は`Callable<String>`などと読み替えていただくとピンと来るでしょう。

hoge

```java
class IO<T1> {
  private final Callable<T1> internalAction;

  IO(Callable<T1> internalAction){
    this.internalAction = internalAction;
  }

  public <T2> IO<T2> then(IO<T2> nextIo){
  }

  public <T2> IO<T2> returnThen(Function<T1, IO<T2>> nextIo){
  }
}
```

# 純粋な関数とIOしかない世界
