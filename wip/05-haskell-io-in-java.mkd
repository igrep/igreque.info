---
title: HaskellのIOは他の言語でいうところの関数オブジェクトだという話
author: Yuji Yamamoto
date: October 25, 2016
tags: Haskell, Monad, Java
...
---

HaskellのIOは奇妙です。  
「純粋な関数だけでプログラムが書けるの？」と多くの方が疑問に思うように、実際のところ、副作用のある操作（入出力。ファイルの読み書きやネットワーク通信など）をしなければ、役に立つプログラムは一切書けません。  
Haskellではそのものズバリ「IO」という機能を使ってそれを実現します。

しかし一方でHaskellは「純粋」なので副作用が一切ない、とも言われます（例えば[Wikipediaのこの辺の説明](https://ja.wikipedia.org/w/index.php?title=Haskell&oldid=59994146#.E5.85.A5.E5.87.BA.E5.8A.9B)）。  
その辺のややこしい問題について、かの[「プログラミングHaskell」](https://estore.ohmsha.co.jp/titles/978427406781P)の訳者、[山本和彦さんの記事](http://d.hatena.ne.jp/kazu-yamamoto/20090627/1246135829)では、下記のように解説されていました（原文のままコピペしています）。

> Haskell の IO では、評価と実行を分離して考える。例として、以下の関数を考えよう。

>
    ```haskell
    putStr :: String -> IO ()
    ```

> putStr は、たとえば putStr "Hello World" のように、String を引数に渡して評価すると、IO () という型の何かを返す。

> このように IO a という型、念のため言うが -> などを含まない単体の IO a という型を持つものを Hakell ではアクションと呼ぶ。僕には、カタカナを使って説明した気になっている人は説明が下手だという信念があるので、日本語に直そう。単体の IO a という型を持つものとは、命令書である。

> つまり、こういうことだ。putStr "Hello World" は、「"Hello World" を標準出力に出力しろ」という命令書を作る。これが実行されてはじめて、"Hello World" が出力される。

今回はここでいう「命令書」という概念を、他の言語のオブジェクトで例えて説明することで、もっと具体的にとらえ直すということに挑戦したいと思います。  
hogeあ、今回もJavaを使いますが、[前回](/posts/2016/04-monad-in-java.html)以上にJavaへの依存度を下げますので、他のオブジェクト指向な言語で説明してもいいんじゃないんじゃないかなぁもと思います。

# はじめにまとめ

hoge

- Haskellの`IO`は他の言語における「引数をとらない関数オブジェクト」と似てる。
- ただし、Haskellの`IO`にはプログラマー自らが直接`IO`を実行するAPIがない。

# 命令「書」

さて、引用した通り、HaskellのIOは命令「書」である、と言えます。  
これはIO（を返す関数）自体は「命令を実行する関数」ではなく命令を表すオブジェクトであるという意味でもあります。  
この記事でいう「オブジェクト」とは「演算の対象になるもの」程度の意味です。[第一級オブジェクト](https://ja.wikipedia.org/wiki/%E7%AC%AC%E4%B8%80%E7%B4%9A%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88)と言い換えてもいいはずでしょう。

つまり、HaskellのIOは「演算の対象になるもの」として変数に格納したり、関数の実行結果として返したり、関数の引数として渡したりできるのです。  
この性質を利用すると、他の言語でよくやる、コールバックのような機能を実現することもできます。Haskellのコードになってしまいますが、一応実例をhogeに置きました。ご興味のあるかたはご覧ください。

さて、「変数に格納したり、関数の実行結果として返したり、関数の引数として渡したりできる」ことに加えてコールバックのような使い方もできる、このようにHaskellのIOをとらえると、なんだか他の言語の関数オブジェクトのようにも思えてきませんか？  
そう、HaskellのIOは、今時な言語ならだいたい実装している、関数オブジェクト（第一級オブジェクトな関数）[^functionObject]とそっくりなのです！

[^functionObject]: 「手続きオブジェクト」と呼ばれたりもします。  
RubyでいうとProcクラスやMethodクラスのオブジェクトであり、C#やVB.NETでは「デリゲート」と呼ばれたりもします。

# Haskellの関数オブジェクトとほかの言語の関数オブジェクト

しかし、Haskellはいわゆる「関数型言語」に属している通り、IOに言及するまでもなく、それとは別に「関数オブジェクト」と呼べるものが存在しています。  
そう、「関数型」の値です。これとIOとの違いはいったいなんなのでしょうか。

一番の違いは、やはりHaskellの関数が「純粋」であるところに由来します。  
Haskellの関数型の値は、例えば「`Int -> String`(`Int`型の値を受け取って`String`型の値を返す関数)」という型宣言で表されるのですが、原則として、**その型に書いてあること以上のことはできません**。「`Int -> String`」な関数は文字通り「`Int`型の値を受け取って`String`型の値を返す」以上のことができないのです（主にデバッグ目的で使われる例外はあります）。  
それに対して**`IO`は、これまた文字通り入出力処理など、他のプログラミング言語（の関数オブジェクト）なら自由にできること**の多くができます。  
`IO`を特別扱いすることによって、`IO`する関数かどうかが型を見るだけでわかるようになっているのです。

加えて、「関数オブジェクト」や「関数型の値」どちらとも大きく異なる点があります。  
**引数をとることができない**のです。引数をとるのは「関数型」の役目、ということになっています。  
例えば、ファイル名を受け取ってそのファイルの中身を読んで返す関数、`readFile`は、以下のような型となっています[^filepath]。

[^filepath]: [実際にドキュメントを読むと](https://hackage.haskell.org/package/base-4.7.0.1/docs/Prelude.html)`readFile`の型は`FilePath -> IO String`となっていますが、`FilePath`は単なる`String`の別名(Rubyで言えばalias)です。  
個人的に別名をつけるのはあまり好きじゃないのですが、まぁこれで普及してしまっているので仕方ありませんね...。

```haskell
readFile :: String -> IO String
```

これは、「`String`（文字列型）を受け取って`IO String`という型を返す関数」という意味です。  
第一引数の`String`はファイル名だとして、はて、`IO String`の`String`というのは一体なんの`String`でしょう？  
これは、`readFile`が返す`IO`（指定された名前のファイルを読み込む関数オブジェクト）を実行した結果
--- すなわちこのケースで言えば読み込んだファイルの中身 --- です。

`IO`は通常このように、型引数として「実行した結果の型」を明示することで使用します。  
`IO String`であれば恐らく「ファイルやソケットなどから読んで文字列を返す関数オブジェクト」でしょうし、`IO Bool`であれば例えば「ファイルの有無を調べて、ファイルがあれば`True`, なければ`False`を返す関数オブジェクト」かもしれません。  
Javaに詳しい方は`Callable<String>`などと読み替えていただくとピンと来るでしょう。

# 他の言語の関数オブジェクトとしてのHaskellのIO

さて、上記をより具体的にイメージしやすくするために、Haskellの`IO`っぽいものをJavaで表現してみましょう。  
ここまでに述べた通り、Haskellの`IO`は、他の言語で例えるなら「引数をとらない関数オブジェクトっぽいもの」なので「関数オブジェクトをラップしたクラス」として表現することとします。実際のHaskellの`IO`はプリミティブなものなのでなにかをラップしているなんてことはないのですが、実際に動くサンプルを作るために必要なので、ご了承ください。

```javascript
class IO {
  constructor(internalAction){
    this.__internalAction = internalAction;
  }

  plus(nextIo){
    return new IO(() => {
      this.__internalAction();
      return nextIo.__internalAction();
    });
  }

  then(makeNextIo){
    return new IO(() => {
      let result = this.__internalAction();
      let nextIo = makeNextIo(result);
      return nextIo.__internalAction();
    });
  }
}
```

hoge

```java
public class IO<T1> {
  private final Callable<T1> internalAction;

  IO(Callable<T1> internalAction){
    this.internalAction = internalAction;
  }

  public <T2> IO<T2> plus(IO<T2> nextIo) {
    return new IO<>(() -> {
      this.internalAction.call();
      return nextIo.internalAction.call();
    });
  }

  public <T2> IO<T2> then(Function<T1, IO<T2>> makeNextIo) {
    return new IO<>(() -> {
      T1 result = this.internalAction.call();
      IO<T2> nextIo = makeNextIo.apply(result);
      return nextIo.internalAction.call();
    });
  }

}
```

詳細に立ち入る前に、最も重要な点を述べます。  
このHaskellの`IO`っぽいものを表現したクラス`IO`は、「関数オブジェクト」と似ていながら、「関数オブジェクト」として**直接実行するAPIを利用者に提供していない**のです。  
それを表すために今回は、ラップした関数オブジェクト(`internalAction`)を`private`にして、`internalAction`を呼び出すメソッド(`call`)を直接呼べないようにしました。  
Haskellでは`IO`は「実行するもの」ではなくあくまでも「組み合わせる」ものであり、後に示します「組み合わせる」ための関数（上記のクラスのメソッド）を用いてのみ操作します。

## `IO`を組み合わせる関数

### 単純に繋げる: `plus`メソッド

最初に単純な`plus`メソッドについて説明しましょう [^haskell-plus]。

[^haskell-plus]: この`plus`メソッドはHaskellでいうところの`>>`関数です。

```java
  public <T2> IO<T2> plus(IO<T2> nextIo) {
    return new IO<>(() -> {
      this.internalAction.call();
      return nextIo.internalAction.call();
    });
  }
```

`plus`メソッドは`return new IO<>()`している通り、新しく`IO`を作って返します。`IO`は関数オブジェクトをラップしたものなので、新しく別の関数オブジェクトを作って渡す必要があります。  
その、新しく作った関数オブジェクトでは何をしているのでしょう？  
最初に`plus`メソッドを呼んだ`IO`オブジェクト自身を呼び出し(`this.internalAction.call()`)、次に引数として渡された`IO`オブジェクトを呼び出す(`nextIo.internalAction.call()`)、ただそれだけです。  
まとめると、「`plus`メソッドを呼び出した`IO`と、引数として与えられた`IO`を**続けて呼び出す新しい`IO`を作る**」、ただそれだけです[^cs-plus]。

[^cs-plus]: 実はこの`plus`メソッド、C#によく似た振る舞いをする演算子があります。名前の通り足し算に使っている`+`演算子です（`plus`メソッドという名前もそこからとりました）。  
C#では関数オブジェクト（デリゲート）同士を`+`で繋ぐことで、両辺の関数オブジェクトを「続けて実行する」新しい関数オブジェクトを作ることができます。詳細は[MSDNのこちらのページ](https://msdn.microsoft.com/ja-jp/library/ms173175.aspx)などをご覧ください。

### 結果を再利用できるようにしつつ繋げる: `then`メソッド

続けて、もうちょっと複雑な`then`メソッドを紹介しましょう [^haskell-then]。

[^haskell-then]: `then`メソッドはHaskellでいうところのあの`>>=`関数です。今回はMonad自体の話はしませんが、これは[前回](/posts/2016/04-monad-in-java.html)`Monad`のメソッドとして作成した`then`メソッドを`IO`が実装したバージョンです。`IO`は`Monad`インターフェースを実装したクラス（Haskellの用語で言えば「`Monad`型クラスのインスタンス」）なのです。

```java
  public <T2> IO<T2> then(Function<T1, IO<T2>> makeNextIo) {
    return new IO<>(() -> {
      T1 result = this.internalAction.call();
      IO<T2> nextIo = makeNextIo.apply(result);
      return nextIo.internalAction.call();
    });
  }
```

まずは`plus`メソッドと同じ部分を列挙します。

1. `plus`メソッドと同様、`return new IO<>()`している通り、新しく`IO`を作って返す。  
  なので`IO`に渡す関数オブジェクトの中で`IO`を組み合わせることとなる。
1. `plus`メソッドと同様、最初に`then`メソッドを呼んだ`IO`オブジェクト自身を呼び出し(`this.internalAction.call()`)、次にもう1つの`IO`オブジェクトを呼び出す(`nextIo.internalAction.call()`)。

大きく異なる点は、`plus`メソッドが`IO<T2> nextIo`を直接受け取っていたのに対して、`then`メソッドが`Function<T1, IO<T2>> makeNextIo`、すなわち「`nextIo`を作る関数」を受けとることに起因します。  
`makeNextIo`は、`plus`メソッドでは無視していた「呼び出しもとの`IO`の実行結果(`this.internalAction.call()`)」を受けとる(`makeNextIo.apply(result)`)ことで初めて`nextIo`を返します。  
そして`makeNextIo`が返した`IO`を実行してその結果を返す --- というのが`then`メソッドが作る`IO`の処理の流れです。  
まとめると、「`then`メソッドを呼び出した`IO`の**結果を使って**引数として与えられた`IO`を作り、それらを**続けて呼び出す新しい`IO`を作る**」、ということとなります。

この後の例でも触れますが、`then`メソッドは、

hoge

# 何が嬉しいの？

# 純粋な関数とIOしかない世界


# 参考

hoge


