---
title: Haskellアプリ作りのためのMonad Overview
author: Yuji Yamamoto
date: May, 2016
tags: Haskell, Monad
...
---

唐突ながら、会社でHaskellを採用する可能性が高まりつつあるので、
チームのメンバーに向けて、Haskellで実践的なアプリを作る上で欠かせない、
Monadの使い方やその実用的な役割にフォーカスした概要を、できるだけ簡潔に説明したいと思う。  
実際には会社で使いながら補足していき、必要に応じてこの記事にも書き足す方向で。

# この文章を読んで知って頂きたいこと

- HaskellにおけるMonadの役割
- MonadがなぜHaskellにおいて必要なのか
- MaybeやState、IOなど、具体的なMonadの簡単な使い方
    - （できれば）それらを使ったアプリやライブラリの実装例、実装パターン

# この文章を読んでも知ることができないこと

- Monadの定義
- Monadとは何なのか
- Monad則とは何なのか
- do記法やMonadの細かい仕組み
- などなど

# 予めおことわり

あくまでも使い方や役割を**感じ取ってもらう**ためのものなので、Monadの定義や実際の構造と照らしあわせていささか不正確な点があることをご了承願いたい。  
幸い、そうした誤解によって間違えたとしても、恐らくコンパイルエラーだけで済むだろうから。

# HaskellにおけるMonadの役割

いわゆる「純粋関数型プログラミング言語」などと知られている通り、Haskellは原則として、
プログラムを全て「純粋な関数」 --- 値を受け取って、返すことしかできない --- で構成するよう設計されている。  
しかしHaskellを敬遠する多くの人の想像するように、
実際のところ、「純粋な関数」だけでは冗長すぎて書きにくい場面も多い。  
例えば、同じ型の変数に関数をいくつも適用したいが、変数名をいくつもつけるのが面倒な場合や、それから、
感じ方の問題ではあるが、設計者が考えたモデルについて、どう考えても状態を持ったものとして表現したほうが適切だと考えられる場合など。  
あと、最もありふれたケースとして、入出力処理をしたい場合も該当する。

定義や理論はともかく、実践上、HaskellのMonadはそうしたニーズをごく自然な書き方で解決するための手段を提供する。  
具体的には、「値を受け取って、返すことしかできない」「純粋な関数」(`a -> b`のような型の関数)の戻り値の型に、
関数の「**権限を表すラベル**」を貼り付けることで、
「この関数は『値を受け取って、返すこと』**以外のこと**もしうるよ！」
ということを型で明示する、と考えるとわかりやすいだろう（し、私自身そのように考えながら関数の型を見る）。  

例えば、関数の型が下記のように異なっていた場合で説明しよう。

```haskell
pureFunction  :: a -> b
stateFunction :: a -> State s b
```

`pureFunction`が「`a`という型の値を受け取って、`b`という型の値を返すことしかできない」「純粋な関数」であるのに対して、
`stateFunction`は、「`a`という型の値を受け取って、`b`という型の値を返しつつ」、
「`s`という型の（とある一つの）変数を更新することもできるよ！」ということを明示している。

Haskellでは関数の型にそうした「権限」を明記し、制限することで、
プログラマは関数の与える影響範囲を簡単に知ることができるし、コンパイラにそれを保証させることができる。

これ以降で使う予定の用語を一点補足しておこう。  
先ほどの`stateFunction`の`b`にくっついた`State s`ような、
「**権限を表すラベル**」がくっついた型の値(`stateFunction`で言えば`State s b`)を、Haskellでは「アクション」だとか「Monadの値」と呼ぶ。  
そして`stateFunction`のような型の関数が返す値(`State s b`という型の値)を「`State` Monadのアクション」と呼ぶ。  
Haskellの型で一般化すると次のようになる。

```haskell
action :: Monad m => m b
```

# 各種Monadひとっ飛び

具体的な使い方は後に回して、ひとまずHaskellの世界にはどんなMonadがあるのか、
そしてそれらが「値を受け取って、返すこと」以外に何ができるか、ざっとリストアップする。  
知っているものを網羅させるが、私の独断と偏見により、重要度に応じて★をつけた。
とりあえずは、★を2つ以上つけたものの使い方だけでも理解していただきたい。

- State Monad (★):
    - `do`ブロックの中で共有している、とある型の変数を**更新**する。
    - `do`ブロックについては後述。
- **Writer Monad** (★★):
    - `do`ブロックの中で共有している、とある型の変数の値に**追記**する。
    - 例えば後述する`IO`を使わずに、ログをログらしく書きたい時などに使う。
- Reader Monad (★):
    - `do`ブロックの中で共有している、とある型の変数を**読む**。
    - 実質普通の関数と変わらないように聞こえる通り、実は普通の関数。
    - アプリケーションの広い範囲で共有する、書き換えない変数を自然に表現するために使う。
        - 外部から読んできた環境設定を表現したり、ダイナミックスコープな定数をシミュレートしたりするのに使う。
- **Maybe Monad** (★★):
    - 関数の実行が失敗した場合に、囲っている`do`ブロックから脱出する。
    - 他の言語でよく使う、「`return null;`などして関数の実行を途中で切り上げるイディオム」のベターな代わりとして使ったりする。
- **Either Monad** (★★):
    - 関数の実行が失敗した場合に、囲っている`do`ブロックから脱出するとともに、失敗した理由を伝える。
    - `throw`を使って、囲っている`try`ブロックを中断する機能の代わりに使う。その特徴から、Error Monadと呼んでもよい。
- List Monad (★):
    - 関数が返した複数の結果を、`do`ブロックの中で総当りで実行する。
    - 例えば他の言語でリストに対する`for`文がたくさんネストしてしまうケースにおいて、ネストをなくすのに使えたりする。
- Cont Monad:
    - 継続Monad。他の言語で言う`break`や`continue`をエミュレートするのに使ったりする。
    - [こういった使い方もある](http://qiita.com/tanakh/items/81fc1a0d9ae0af3865cb)。
    - 直接使うことは稀だと思うのでむやみに理解する必要はない。というか、私も仕組みを理解していない。
- **IO Monad** (★★★):
    - おなじみ入出力処理に加え、C言語で定義した関数の呼び出し、`IORef`という特殊な型の変数の破壊的変更、例外の送出など、だいたいなんでもできる。
    - 一言で言うとワイルドカードのようなMonad。
    - 必要以上に使えば使うほど、Haskellで書くメリットが減っていくのでご利用は計画的に。
- ST Monad:
    - `STRef`という特殊な型の変数の更新をする。
    - イミュータブルなデータ構造として作ると効率が悪い、配列などを操作したい場合に使う。
- Identity Monad:
    - 何もしない。後述するMonad Transformerから、通常のMonadを簡単に作るのに使う。
    - そのMonad Transformerを組み合わせて新しいMonadを作ろうとでも思わない限り、直接使うケースはないだろう。

- Free Monad:
    - Functorという型クラスを実装した型から、新たなMonadを簡単に作り出すための特殊なMonad。
- Operational Monad:
    - Free Monadを応用して、Functorを実装した型じゃなくても簡単に新しいMonadを作れるすごい特殊なMonad。

- **Monad Transformerと呼ばれるもの全般** (★★):
    - ここまでに挙げた、各種Monadが「値を受け取って、返す以外にできること」を、**同時に複数**使用できるようにする仕組み。
    - 大きめのアプリケーションにおいてしばしばあるケースなので、これも使い方だけは抑えたい。

- Monad\*という名前がついた型クラスに属する各種Monad (★):
    - 例えばMonadIO、MonadState、MonadWriter、MonadBaseControlなど。
    - ここまでに並べたとおり、Monadもいろいろあるので、似たようなものがそうした型クラスでまとめられている。
    - 「値を受け取って、返す以外に、hogehogeができるMonad」の「hogehoge」ごとに型クラスとして抽象化している。
- その他
    - これまでに挙げた様々なMonadを、各アプリケーションやライブラリ専用に組み合わせたものが多い。
    - 後はSTMやEvalなど、並列処理や並行処理用に作られたやつか。
        - 詳しくは<a href="http://www.amazon.co.jp/gp/product/4873116899/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=4873116899&amp;linkCode=as2&amp;tag=poe02-22">Haskellによる並列・並行プログラミング</a><img src="http://ir-jp.amazon-adsystem.com/e/ir?t=poe02-22&amp;l=as2&amp;o=9&amp;a=4873116899" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />を参照されたし。

# Monadの一般的な使い方

一部には`do`記法禁止、なんていう規約を設けているところもあるらしいが、
通例Monadは「`do`記法」という特別な構文糖（シンタックスシュガー）を介して使用すると、わかりやすく直感的に書けることが多い。  
そのため、以下にMonad全般（もちろん、ここまでに紹介したものを含む）で使用できる、「`do`記法」という構文糖の使い方を、
ある意味最も身近なMonadであろう、IO Monadを例に示す。

IOには、例えば下記のような型のアクション（と、アクションを返す関数）がある。

```haskell
-- 標準入力から文字列を一行読み出し、返すアクション
getLine :: IO String

-- 第一引数としてファイル名受け取り、その中身を全て読み出し、返すアクション
readFile :: String -> IO String
```

これらを`do`記法で使用する際は、下記のように`do`という予約語で始まるブロックの中に書く。

```haskell
do
  line <- getLine
  readFile line
```

`do`と書かれた行からインデントを一段下げた行までを「`do`ブロック」と言う。

`do`ブロックはその中で実行しているアクションの型の値を返す。
`do`ブロックは値を返すので、当然ながら変数に代入することができる。  
したがって下記の`largerAction`の型は`IO String`となる。

```haskell
largerAction :: IO String
largerAction = do
  line <- getLine
  readFile line
```

`do`ブロックが返す値は、`do`ブロックの中に列挙したアクションを「続けて実行する」アクションとなる。  
なので上記の`do`ブロックは、「`getLine`してから`readFile`する」アクションを返す。

`do`ブロックの中では、`<-`という記号を利用して、アクションの「結果」を変数に代入することができる。  
アクションの「結果」とは、アクションを「実際に実行した結果」を表す。  
そしてその型はアクションから「権限を表すラベル」を**剥がした**型となる。  
上記の例で言うと、`line <- getLine`という行が該当する。  
`line`には`getLine`を実行した結果、すなわち「標準入力から文字列を一行読みだした結果の文字列」が代入され、
その型は`IO String`から`IO`を剥がした型`String`となる。

`<-`で代入した変数は、もちろん`do`ブロックの中で他の関数に渡すことができる。
なので当然ながら上記の`readFile`は`line`を引数として受け取ることができる。

`do`ブロックの最後の行に書かれたアクションの実行結果が、`do`ブロック全体の最終的な実行結果となる。  
やはりその型は最後の行に書かれたアクションの型がそのまま引き継がれる。  
上記の例で言うと`readFile :: String -> IO String`に引数を一つ適用した結果、つまり`IO String`となる。

まとめると上記のアクションは、「`getLine`した結果を`readFile`して、その結果を返す」アクション、
日本語に訳すと「標準入力から一行分読んだ文字列をファイル名として、その中身を読んで返す」アクションである。

`do`ブロックの中で、アクションでない値、すなわち「値を受け取って、返すことしかできない」、
純粋な関数で作った値を作りたくなる場合も、当然あるだろう。  
そのような場合は、`let`を使う。

例として、先程まで使った例を少し改造しよう。  
ファイル名を`getLine`で受け取ってから、
[MissingHというパッケージのData.String.Utilsモジュールにある、strip関数](https://hackage.haskell.org/package/MissingH-1.3.0.1/docs/Data-String-Utils.html)を使用して、
ファイル名の前後に含まれてしまった空白文字を取り除き、更に拡張子を加えてみよう。

```haskell
largerAction :: IO String
largerAction = do
  line <- getLine
  let path = strip line
      prefixedPath = path ++ ".dat"
      -- 通常のHaskellのletと異なり "in" は省略できる点に注意。
  readFile prefixedPath
```

上記の通り`let`で代入した変数は後続のアクションや、`let`式の中で利用することができる。

## `do`ブロックの中でやってはいけない（できない）こと

`do`

# Monadの使用例つまみ食い


