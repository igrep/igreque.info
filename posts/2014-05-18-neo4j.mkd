---
title: Neo4jについてちょちょいと調べたまとめ
author: Yuji Yamamoto
tags: Neo4j
...
---

Neo4jについて、Eightでも使えないかな、なんて考えつつ調べていました。
なので本日はそれについて備忘録的なのを。 \
なお、調べた時点のNeo4jのバージョンは2.0です。
そしてこの文章はNeo4jを実際に使ってみた感想ではなく、
ちょちょっと本やブログ記事などを読んで得た程度に知識である点をご了承ください。

# そもそもNeo4jって？

「property graph」というデータモデルを採用した、GraphDBの一種です。
この分野では最も有名なものとして知られている模様です。 \
ひとまず、このへんの用語のお話は、参考にした下記のサイトや電子書籍にお任せします。

foo

# 速さの秘密について

Neo4jの人気の理由をまず一つ挙げるならば、
グラフ構造でデータを保存した場合の、探索効率の高さでしょう。
例えば下記のようなグラフにおいて、
「『Aさんと直接名刺交換した人』と名刺交換した人のうち、まだAさんと名刺交換してない人」
みたいな問い合わせに回答するときに、
RDBをはるかに凌ぐようなパフォーマンスを出すことができます。

```dot
digraph namecard1 {
  graph [label = "名刺交換の記録を表すグラフ"]
  Aさん --- Bさん --- Cさん --- Dさん;
  Aさん --- Eさん --- Fさん --- Dさん;
  Aさん --- Cさん;
  Dさん --- Eさん;
}
```

具体的にどう速いのかというと、
上記のような問い合わせにおいて、「Aさんと名刺交換した人」を求めるのに、
RDBですと「**テーブル全体のレコード数**の対数（log(n)）foo」に対して比例した時間がかかる[^btree]
のに対して、
Neo4j（あるいは似たデータ構造を持つGraphDB）だと、
「**Aさんと直接名刺交換した人の数**」に比例した時間のみがかかります。
一般に、テーブル全体のレコード数（この場合、名刺交換をした人々を表すレコード群の数）は、
個々のレコードにつながるレコード数（この場合、ある人と直接名刺交換した人の集合の数）
よりも圧倒的に多いため、
後者にしか影響を受けないNeo4jの探索は、速いのです。
とりわけ、「Aさんと名刺交換した人と名刺交換した人」のような、
二次、三次のつながりをたどる場合、
RDBの場合はつながりの数だけインデックスを1から辿らなくてはならないため、
更にその差は大きくなります。

[^btree]: もちろん、2分木によるインデックスを利用していた場合の話です。

## index-free adjacency

なぜこのような、「個々のレコードにつながるレコード数」のみに影響を受ける探索ができるのでしょう？
その秘密は、やはりデータ構造にあり、
「index-free adjacency」という性質がキーとなっています[^japanese]。

[^japanese]: 日本語に訳すなら、「インデックスなし隣接性」か、
はたまたそのまま「インデックスフリー隣接性」とカタカナ語をもっと駆使するのがよいでしょうか。
いずれにしても、「アドジェイスンシー」という単語はカタカナ語としては発音しにくすぎです。

「index-free adjacency」とは何でしょうか。
当記事の主な情報源となった、
そのものずばり「[Graph　Databases](http://graphdatabases.com/)」によれば、
「index-free adjacency」な特性を持つNeo4jでは、
各ノード・リレーションは、固定長のレコードとして保存され、
レコードの中に、直接隣接しているノード、またはレコードへの、
**物理的なアドレス**を記録しているのです。
「物理的なアドレス」とはどういうことでしょう？
例えば、1レコードの長さが9バイトだとして、
「物理的なアドレス」が「100」のレコードがあったとすると、
そのレコードはファイルの先頭から数えて、ちょうど900バイト目にあることとなります。
このレコードを参照するには、ファイルの先頭から900バイト目までseekするだけでよい、
ということになるので、仮にキャッシュにヒットせず、
ファイルからノード・リレーションを読み込んだとしても、幾分参照が楽になるのです。

ここまで読んだ方の中には、
「ちょっと待てよ、Neo4jのノードは複数のリレーションを持つことができるんだろ？
どうやって固定長のレコードの中に複数のリレーションへのアドレスを詰め込むんだ？」
と疑問に思う方もいらっしゃるかもしれません。
その理由は、まぁ、ある程度データ構造について知識がある方はすぐに察しがつくでしょう、
リンクリストになっているからです。
このことをもう少し詳しく説明するために、
ノードを表すレコード（ノードレコード）とリレーションを表すレコード（リレーションレコード）が、
どのように互いの物理的なアドレスを参照しあっているか、図にしてみましょう。
Neo4jのグラフを表すグラフです[^no-property]。

[^no-property]: ここでは、
ノードやリレーションのプロパティを表すレコードについては割愛させていただきます。
詳細は前述の「[Graph　Databases](http://graphdatabases.com/)」をご覧ください。
電子版が無料でダウンロードできます。

# 遅さの秘密について

# 拡張性について

## Capacity
## Sharding

# 柔軟性について

# トランザクションの仕様について

# 静的型付け言語との相性について

# ライセンスについて
