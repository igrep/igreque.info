---
title: Neo4jについてちょちょいと調べたまとめ
author: Yuji Yamamoto
tags: Neo4j
...
---

Neo4jについて、Eightでも使えないかな、なんて考えつつ調べていました。
なので本日はそれについて備忘録的なのを。 \
なお、調べた時点のNeo4jのバージョンは2.0です。
そしてこの文章はNeo4jを実際に使ってみた感想ではなく、
ちょちょっと本やブログ記事などを読んで得た程度に知識である点をご了承ください。

# そもそもNeo4jって？

「property graph」というデータモデルを採用した、GraphDBの一種です。
この分野では最も有名なものとして知られている模様です。 \
ひとまず、このへんの用語のお話は、参考にした下記のサイトや電子書籍にお任せします。

foo

# 速さの秘密について

Neo4jの人気の理由をまず一つ挙げるならば、
グラフ構造でデータを保存した場合の、探索効率の高さでしょう。
例えば下記のようなグラフにおいて、
「『Aさんと直接名刺交換した人』と名刺交換した人のうち、まだAさんと名刺交換してない人」
みたいな問い合わせに回答するときに、
RDBをはるかに凌ぐようなパフォーマンスを出すことができます。

```dot
digraph namecard1 {
  graph [label = "名刺交換の記録を表すグラフ"]
  Aさん --- Bさん --- Cさん --- Dさん;
  Aさん --- Eさん --- Fさん --- Dさん;
  Aさん --- Cさん;
  Dさん --- Eさん;
}
```

具体的にどう速いのかというと、
上記のような問い合わせにおいて、「Aさんと名刺交換した人」を求めるのに、
RDBですと「**テーブル全体のレコード数**の対数（log(n)）foo」に対して比例した時間がかかる[^btree]
のに対して、
Neo4j（あるいは似たデータ構造を持つGraphDB）だと、
「**Aさんと直接名刺交換した人の数**」に比例した時間のみがかかります。
一般に、テーブル全体のレコード数（この場合、名刺交換をした人々を表すレコード群の数）は、
個々のレコードにつながるレコード数（この場合、ある人と直接名刺交換した人の集合の数）
よりも圧倒的に多いため、
後者にしか影響を受けないNeo4jの探索は、速いのです。
とりわけ、「Aさんと名刺交換した人と名刺交換した人」のような、
二次、三次のつながりをたどる場合、
RDBの場合はつながりの数だけインデックスを1から辿らなくてはならないため、
更にその差は大きくなります。

[^btree]: もちろん、2分木によるインデックスを利用していた場合の話です。

## index-free adjacency

なぜこのような、「個々のレコードにつながるレコード数」のみに影響を受ける探索ができるのでしょう？
その秘密は、やはりデータ構造にあり、
「index-free adjacency」という性質がキーとなっています[^japanese]。

[^japanese]: 日本語に訳すなら、「インデックスなし隣接性」か、
はたまたそのまま「インデックスフリー隣接性」とカタカナ語をもっと駆使するのがよいでしょうか。
いずれにしても、「アドジェイスンシー」という単語はカタカナ語としては発音しにくすぎです。

「index-free adjacency」とは何でしょうか。
当記事の主な情報源となった、
そのものずばり「[Graph　Databases](http://graphdatabases.com/)」によれば、
「index-free adjacency」な特性を持つNeo4jでは、
各ノード・リレーションは、固定長のレコードとして保存され、
レコードの中に、直接隣接しているノード、またはリレーションへの、
**物理的なアドレス**を記録しているのです。
「物理的なアドレス」とはどういうことでしょう？
例えば、1レコードの長さが9バイトだとして、
「物理的なアドレス」が「100」のレコードがあったとすると、
そのレコードはファイルの先頭から数えて、ちょうど900バイト目にあることとなります。
このレコードを参照するには、ファイルの先頭から900バイト目までseekするだけでよい、
ということになるので、仮にキャッシュにヒットせず、
ファイルからノード・リレーションを読み込んだとしても、幾分参照が楽になるのです。

ここまで読んだ方の中には、
「ちょっと待てよ、Neo4jのノードは複数のリレーションを持つことができるんだろ？
どうやって固定長のレコードの中に複数のリレーションへのアドレスを詰め込むんだ？」
と疑問に思う方もいらっしゃるかもしれません。
その理由は、まぁ、ある程度データ構造について知識がある方はすぐに察しがつくでしょう、
リンクリストになっているからです。
このことをもう少し詳しく説明するために、
ノードを表すレコード（ノードレコード）とリレーションを表すレコード（リレーションレコード）が、
どのように互いの物理的なアドレスを参照しあっているか、図にしてみましょう。
Neo4jのグラフを表すグラフです[^no-property]。

[^no-property]: ここでは、
ノードやリレーションのプロパティを表すレコードについては割愛させていただきます。
詳細は前述の「[Graph　Databases](http://graphdatabases.com/)」をご覧ください。
電子版が無料でダウンロードできます。

```dot
digraph neo4j-graph-graph {
  graph [label = "Neo4jのグラフのグラフ"]
  NodeA --> Rel1 [label = "nextRel"];
  NodeA <-- Rel1 [label = "firstNode"];
  NodeB --> Rel1 [label = "nextRel"];
  NodeB <-- Rel1 [label = "secondNode"];
  Rel1 --> RelA2 [label = "firstNextRel"];
  Rel1 --> RelB2 [label = "secondNextRel"];
  RelA2 --> Rel1 [label = "firstPrevRel"];
  RelB2 --> Rel1 [label = "secondPrevRel"];
  NodeA <-- RelA2 [label = "firstNode or secondNode"];
  NodeB <-- RelB2 [label = "firstNode or secondNode"];
}
```

上記のグラフでは、例えば`NodeA -- nextRel --> Rel1`と書かれている場合、
「`NodeA`が`Rel1`の、
物理的なアドレスを『`nextRel`（次のリレーション）』として持っている（参照している）」
という関係を表しております。

ご覧の通り、1個のノードレコード(`NodeA, NodeB`)は、
自分が持っている最初のリレーションレコード(`Rel1`)へのアドレスしか持っていません。
そしてノードが持つその他のリレーションへのアドレスは、
「最初のリレーション」が`firstNextRel`、または`secondNextRel`として参照しているのです。
これらは名前から察せられる通り、
それぞれリレーションにつながる「片方のノードが持つ次のリレーション」と、
「もう片方のノードが持つ次のリレーション」を表します。
こうしたつながりを続けて1つずつ参照するため、
Neo4jの探索は
「個々のノードにつながるリレーションの数」のみに比例した時間で実行できるのです。

# 遅さの秘密について

このように優れた特性を持つNeo4jですが、
この「index-free adjacency」という性質のせいで、却って著しく遅くなってしまうケースがあります。
「index-free adjacency」は「速さの秘密」であるとともに、「遅さの秘密」でもあるのです。
そうしたケースを、[CyberAgentの松本陽介さんが書いた論文](https://www.cyberagent.co.jp/technology/ca_tech/report/8980456.html)が示してくれました。
松本陽介さんによれば、ノードにつながるリレーションの数が、
1万以上まで達すると、探索が非常に遅くなってしまい、使いものにならなくなってしまうそうです。
そのため、Amebaのような、
一人のユーザーがつながる数が10万以上まで達することがある大規模なサービスでは、
採用は難しいとのことです。

先ほど説明した、
「個々のノードにつながるリレーションの数に比例した時間での探索」
という特徴から、冷静に考えてみれば、これは当たり前の問題です。
どうやらNeo4j（と、その他同様のデータモデルを持つGraphDB）には、
グラフを扱うデータベースでありながら、
巨大なグラフを扱う上で致命的な問題を抱えているようです。
ぱっと見いかにも向いていそうな、
TwitterやFacebookなどが採用しないのにも、恐らくこうした背景があるのでしょう。

# 拡張性について

## Capacity
## Sharding

# 柔軟性について

# トランザクションの仕様について

# 静的型付け言語との相性について

# ライセンスについて
