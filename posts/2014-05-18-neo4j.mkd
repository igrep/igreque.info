---
title: Neo4jについてちょちょいと調べたまとめ
author: Yuji Yamamoto
tags: Neo4j
...
---

Neo4jについて、Eightでも使えないかな、なんて考えつつ調べていました。
なので本日はそれについて備忘録的なのを。 \
なお、調べた時点のNeo4jのバージョンは2.0です。
そしてこの文章はNeo4jを実際に使ってみた感想ではなく、
ちょちょっと本やブログ記事などを読んで得た程度に知識である点をご了承ください。

# そもそもNeo4jって？

「property graph」というデータモデルを採用した、GraphDBの一種です。
この分野では最も有名なものとして知られている模様です。 \
ひとまず、このへんの用語のお話は、参考にした下記のサイトや電子書籍にお任せします。

foo

# 速さの秘密について

Neo4jの人気の理由をまず一つ挙げるならば、
グラフ構造でデータを保存した場合の、探索効率の高さでしょう。
例えば下記のようなグラフにおいて、
「『Aさんと直接名刺交換した人』と名刺交換した人のうち、まだAさんと名刺交換してない人」
みたいな問い合わせに回答するときに、
RDBをはるかに凌ぐようなパフォーマンスを出すことができます。

```dot
digraph namecard1 {
  graph [label = "名刺交換の記録を表すグラフ"]
  Aさん --- Bさん --- Cさん --- Dさん;
  Aさん --- Eさん --- Fさん --- Dさん;
  Aさん --- Cさん;
  Dさん --- Eさん;
}
```

具体的にどう速いのかというと、
上記のような問い合わせにおいて、「Aさんと名刺交換した人」を求めるのに、
RDBですと「**テーブル全体のレコード数**の対数（log(n)）foo」に対して比例した時間がかかる[^btree]
のに対して、
Neo4j（あるいは似たデータ構造を持つGraphDB）だと、
「**Aさんと直接名刺交換した人の数**」に比例した時間のみがかかります。
一般に、テーブル全体のレコード数（この場合、名刺交換をした人々を表すレコード群の数）は、
個々のレコードにつながるレコード数（この場合、ある人と直接名刺交換した人の集合の数）
よりも圧倒的に多いため、
後者にしか影響を受けないNeo4jの探索は、速いのです。
とりわけ、「Aさんと名刺交換した人と名刺交換した人」のような、
二次、三次のつながりをたどる場合、
RDBの場合はつながりの数だけインデックスを1から辿らなくてはならないため、
更にその差は大きくなります。

[^btree]: もちろん、2分木によるインデックスを利用していた場合の話です。

## index-free adjacency

なぜこのような、「個々のレコードにつながるレコード数」のみに影響を受ける探索ができるのでしょう？
その秘密は、やはりデータ構造にあり、
「index-free adjacency」という性質がキーとなっています[^japanese]。

[^japanese]: 日本語に訳すなら、「インデックスなし隣接性」か、
はたまたそのまま「インデックスフリー隣接性」とカタカナ語をもっと駆使するのがよいでしょうか。
いずれにしても、「アドジェイスンシー」という単語はカタカナ語としては発音しにくすぎです。

「index-free adjacency」とは何でしょうか。
ここではそれを説明するために、電子版が無料で読める、そのものずばり
「[Graph　Databases](http://graphdatabases.com/)」に書かれていた、
Neo4jの物理的なデータ構造の図を引用してみます。

# 遅さの秘密について

# 拡張性について

## Capacity
## Sharding

# 柔軟性について

# トランザクションの仕様について

# 静的型付け言語との相性について

# ライセンスについて
