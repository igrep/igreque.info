% 改めて定義から考えるHaskellのMonad
% 山本悠滋
% 2014-05-11

# はじめまして！

- 山本悠滋 25歳♂
- Sansanという会社でRails触ってます。
- [Haskellの勉強会](http://connpass.com/series/754/)をツキイチでやってます！

# 今日話すこと・話さないこと

- やたら難しいと言われる**Haskellの**Monadについて私なりの理解を説明してみます。
    - これ↓
    ```haskell
    class Monad m where
      return :: a -> m a
      (>>=) :: m a -> (a -> m b) -> m b
      -- 以下略
    ```
- **圏論の**モナドはよくわかりません！
- 「もう知ってるぜ！」という部分も多いかとはあしからず。
<!-- すでに知ってるよ！みたいな話かもしれませんが... -->

# Monadは型クラス

- （再掲）こんな感じで↓

    ```haskell
    class Monad m where
      return :: a -> m a
      (>>=) :: m a -> (a -> m b) -> m b
      -- 以下略
    ```

- こんなふうに使うやつ

    ```haskell
    mapM :: Monad m => (a -> m b) -> [a] -> m [b]
    mapM f as = sequence (map f as)
    ```

# そもそも型クラスって

- まぁ言ってしまえば
    - JavaやC#などのinterface
    - Rubyのmix-inされるmodule
- のようなもの

# そもそも型クラスって

- すなわち
    - 同じ振る舞いをする型たちをひっくるめて扱うための仕組み

# 型クラスのいいところ

- 新しい型を作った時、必要なメソッドを定義しておくだけで、
  **その型クラスに対して使える色々な関数が使える！**
- 新しい型に固有な、**新しい型のみに必要な処理**は、必要な（未定義の）メソッドに**全て押し込めちゃえばいい！**

# 型クラスのいいところ

- 例: Ordクラス
- 必要なcompareメソッドを定義しておくだけで！
    - sortできたり、
    - 探索木の要素にしたり、
- いろいろできる！

# では、Monadはどうでしょう？

- 必要なreturnメソッドと(\>\>=)メソッドを定義しておくだけで！
    - do記法を使ったり、
- いろいろできる！

# では、Monadはどうでしょう？

- みたびMonadの定義↓

    ```haskell
    class Monad m where
      return :: a -> m a
      (>>=) :: m a -> (a -> m b) -> m b
      -- 以下略
    ```

# （再掲）型クラスのいいところ

- 新しい型を作った時、必要なメソッドを定義しておくだけで、
  **その型クラスに対して使える色々な関数が使える！**
- 新しい型に固有な、**新しい型のみに必要な処理**は、必要な（未定義の）メソッドに**全て押し込めちゃえばいい！**

# Monadのいいところ

- 新しいMonad（クラスのインスタンス）を作った時、必要なメソッドを定義しておくだけで、
  **そのMonadに対して使える色々な関数が使える！**
- 新しいMonad（クラスのインスタンス）に固有な、新しいMonadのみに必要な処理は、**必要な（未定義の）メソッド**に全て押し込めちゃえばいい！

# Monadの「必要な（未定義の）メソッド」と言えば...

- やっぱりこれ！↓

    ```haskell
    return :: a -> m a
    (>>=) :: m a -> (a -> m b) -> m b
    ```

# （再掲）Monadのいいところ

- 新しいMonad（クラスのインスタンス）に固有な、**新しいMonadのみに必要な処理**は、必要な（未定義の）メソッドに**全て押し込めちゃえばいい！**

# 「新しいMonadのみに必要な処理」はどこに押し込める？

- メソッドでしょ！
- 具体的にはreturnと(\>\>=)でしょ！

# では「新しいMonadのみに必要な処理」ってどんな処理？

- こんな処理です（本日n回目のコピペ）↓

    ```haskell
    return :: a -> m a
    (>>=) :: m a -> (a -> m b) -> m b
    ```

- returnと(\>\>=)の中に、必要な処理が入る！

# ここで(\>\>=)だけを見てみましょう！！
