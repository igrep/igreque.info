% Monad as "Things to Do"
% Yuji Yamamoto
% 2015-05-25

# Nice to meet you!

- [Yuji Yamamoto](https://plus.google.com/u/0/+YujiYamamoto_igrep/about)([\@igrep](https://twitter.com/igrep)) age 26.
- Japanese Ruby engineer working at [Sansan](http://www.corp-sansan.com/).
- Hobby Haskeller.
- Holding [workshop of Haskell (Japanese)](http://connpass.com/series/754/) per month.

# I'm gonna talk about...

- Describe Monad **in Haskell** from a programmer's point of view.
    - This↓
    ```haskell
    class Monad m where
      return :: a -> m a
      (>>=) :: m a -> (a -> m b) -> m b
      -- snip. --
    ```
- I don't know much about Monad in category theory.
- Disclaimer: you might already know much part of this talk.

# In short,

- I got **fairy sure** of Monad in Haskell by interpreting it as \
  "*things to do* every time returning a value of a function"

# Monad is a type class

- Like this (reprinted) ↓

    ```haskell
    class Monad m where
      return :: a -> m a
      (>>=) :: m a -> (a -> m b) -> m b
      -- snip. --
    ```

# Recall what a type class is:

- something like...
    - Interface in Java and C# etc.
    - Module providing mix-in in Ruby.
- **=\> Provides a way to put types with same behavior altogether!**

# Why type class is useful

- When creating a type, **Get various functions available for the type class** \
  only by defining the required methods.
- The only thing to do is to write all the computation unique to the new type in the required (undefined) methods!.

# Then, how about Monad?

- By defining only `return` and `>>=` method,
    - `do` notation available!
- And more!
- Write only computation unique to a new Monad (its instance) \
  in the required (and undefined) method!

# Let's see (\>\>=) method!

```haskell
(>>=) :: m a -> (a -> m b) -> m b
```

- Like the other type classes, Monad abstracts types  \
  by defining the unique computation in the required `>>=` method.

# Let's see (\>\>=) method!

```haskell
(>>=) :: m a -> (a -> m b) -> m b
```

- For example...
    - In `Maybe`, `>>=` *checks Just a or Nothing* \
      before passing `a` of `m a` to `(a -> m b)`.
    - In `Reader`, `>>=` *supplies the missing argument to the reader function* \
      before passing `a` of `m a` to `(a -> m b)`.
    - In `Parser`, `>>=` *consumes the given string* \
      before passing `a` of `m a` to `(a -> m b)`.

# Let's see (\>\>=) method!

```haskell
(>>=) :: m a -> (a -> m b) -> m b
```

- いずれも、
    - `m a`の`a`を`(a -> m b)`に渡すために、 \
      **必要な処理をそれぞれ持っている。**
- そして、
    - `(a -> m b)`が返した`m b`をまた別の関数に渡すよう、必要な処理を繰り返している。

# つまり！！

- Monadは(\>\>=)の`m a`の`a`を`(a -> m b)`に渡す部分に、 \
  やらなければならないことをすべて押し込んでいる！
- `(a -> m b)`が値を返す度に、 \
  別の`(a -> m b)`な関数にMonadに包まれていない値を渡すために、 \
  やらなければならないことを(\>\>=)に任せている。

# 要するに！！

- `(a -> m b)`という型の、 \
  **値を返す度に、やらなければならないことがある関数** \
  がいっぱいある時、Monadは役に立つ。

# 例えば！！

- 「失敗したのかどうか、実行する度に確認しなきゃいけない」 \
  関数がいっぱいあるときは、 \
  **=\> Maybe Monad**
- 「実行する度に、結果のログを追記しなきゃいけない」 \
  関数がいっぱいあるときは、 \
  **=\> Writer Monad**
- 「実行する度に、入出力など、何かしら副作用のある計算をしなきゃいけない」 \
  関数がいっぱいあるときは、 \
  **=\> IO Monad**

# で、なにがうれしいの？

- 「[文脈](http://d.hatena.ne.jp/kazu-yamamoto/20110413/1302683869)だ！」とか、
- 「[手続き](http://fumieval.hatenablog.com/entry/2013/06/05/182316)だ！」とか、
- 「いや[モナド](http://fumieval.hatenablog.com/entry/2013/06/28/224439)だ！」とか、
- いろいろとMonadを簡単に言い換える言葉は多く出てきたけど、 \
  どれも結構抽象的で、ピンと来なかった。

# で、なにがうれしいの？

- それに対して「関数が値を返すたびにやらなければならないこと」だと、
    - 少なくともわれわれプログラマはイメージしやすい（はず）。
    - あくまでも「型クラスとしてのMonad」の性質に即して説明できる。
    - 「どう役立つか」説明できるので、メリットを感じさせやすい。
        - 特に「毎回やらなければならないことを一箇所にまとめられる」と言えば、
          コードのDRYさに敏感な人に効果がありそう。
    - 「失敗系」とか「状態系」とかに分けなくていい。

# まとめ

- HaskellのMonadは型クラス
- 型クラスは、同じ振る舞いをする型達を、まとめて扱うために使用する。
- Monadは「値を返すたびにやらなければならないこと」をまとめる。
- こうして、おびただしい数のMonadチュートリアルの歴史に、
  また一つ新たなページを刻んでしまうのであった...。
